<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms explained on Algorithms to Go</title>
    <link>https://yourbasic.org/algorithms/</link>
    <description>Recent content in Algorithms explained on Algorithms to Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://yourbasic.org/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algorithms: What’s the problem?</title>
      <link>https://yourbasic.org/algorithms/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/algorithms/</guid>
      <description>A good programmer describes algo&amp;shy;rithms in a form that can be&amp;nbsp;effi&amp;shy;ciently exe&amp;shy;cuted by&amp;nbsp;ma&amp;shy;chines and easily under&amp;shy;stood by&amp;nbsp;humans.
 Algorithms and programs are pretty much the same thing &amp;ndash; the main difference is that we can talk about algorithms without relying on a programming language. An algorithm invented today will be equally as useful when the last Java programmer has logged&amp;nbsp;out. Here is an attempt at a formal definition.
 An algorithm is a stepwise procedure of well-defined executable instructions intended to perform a task or solve a problem, often with the added requirement that the procedure must come to a stop.</description>
    </item>
    
    <item>
      <title>Amortized time complexity</title>
      <link>https://yourbasic.org/algorithms/amortized-time-complexity-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/amortized-time-complexity-analysis/</guid>
      <description>Amortized analysis is used for algo&amp;shy;rithms that have expensive opera&amp;shy;tions that happen only&amp;nbsp;rarely.
 Amortized complexity analysis is most commonly used with data structures that have state that persists between operations. The basic idea is that an expensive operation can alter the state so that the worst case cannot occur again for a long time, thus amortizing its cost.
Let T1, T2,&amp;nbsp;…, Tk be the complexities of a sequence of operations on a data structure.</description>
    </item>
    
    <item>
      <title>API design: principles and best practices</title>
      <link>https://yourbasic.org/algorithms/your-basic-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/your-basic-api/</guid>
      <description>Introduction The 5 Commandments 1. Tell me what this thing is 2. Tell me what it does 3. Don&#39;t tell me how it works 4. Grant me the right to use it 5. Don&#39;t change it   Keep it simple Don&#39;t use complicated constructs where simple ones will do Don&#39;t use a lot where a little will do One package, one idea Just say no Math is simple   Give it time Eat your own dog food   Show, don&#39;t tell Create tutorials Use examples   Tools of the trade Keep it consistent Write functions that need little and give much Discover a well-fitting interface Make it generic Names, keep them short and sweet    Introduction The aim of this text is to explore API design and try to find strategies and rules that can help us create code libraries that are safe, effective and easy to use.</description>
    </item>
    
    <item>
      <title>Big O notation: definition and examples</title>
      <link>https://yourbasic.org/algorithms/big-o-notation-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/big-o-notation-explained/</guid>
      <description>Big O notation is a convenient way to describe how fast a function is&amp;nbsp;growing.
 Definition Constant time Linear time Quadratic time   Sloppy notation Ω and Θ notation Key takeaways     Definition When we compute the time complexity&amp;nbsp;T(n) of an algorithm we rarely get an exact result, just an estimate. That&amp;rsquo;s fine, in computer science we are typically only interested in how fast T(n) is growing as a function of the input size&amp;nbsp;n.</description>
    </item>
    
    <item>
      <title>Binary search trees explained</title>
      <link>https://yourbasic.org/algorithms/binary-search-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/binary-search-tree/</guid>
      <description>Binary tree definitions Binary search tree Example   Balanced trees with O(log n) time complexity Tree algorithms Inorder traversal Search Insert    Binary tree definitions A binary tree is a data structure most easily described by&amp;nbsp;recursion.
 A binary tree  is either empty,  or consists of a node (also known as the root of the tree) and two subtrees, the left and right subtree, which are also binary trees.</description>
    </item>
    
    <item>
      <title>Blackjack card counting risk analysis: poor gains at huge risk</title>
      <link>https://yourbasic.org/algorithms/blackjack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/blackjack/</guid>
      <description>It’s possible to win at blackjack by counting cards, but most&amp;nbsp;fail. The mean is positive, but the variance is&amp;nbsp;mean.
 Always optimal strategy  Always use an optimal strategy adapted to the rules of your casino. Here is an example blackjack strategy. Every time you deviate from the optimal strategy – because of hunches or fear – it depletes your funds. Count cards  If you find a casino with good rules, and if you play with an optimal strategy, the odds are still against you – but the house edge can sometimes be as low as&amp;nbsp;0.</description>
    </item>
    
    <item>
      <title>Bloom filters explained</title>
      <link>https://yourbasic.org/algorithms/bloom-filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/bloom-filter/</guid>
      <description>A Bloom filter is a prob&amp;shy;abi&amp;shy;listic data struc&amp;shy;ture used to test set&amp;nbsp;member&amp;shy;ship.
 Bloom filter basics Example: Blocking shady websites Implementation Performance  Bloom filter basics The Bloom filter data structure tells whether an element may be in a set, or definitely isn&amp;rsquo;t. The only possible errors are false positives: a search for a nonexistent element can give an incorrect answer. With more elements in the filter, the error rate increases.</description>
    </item>
    
    <item>
      <title>Dynamic programming [step-by-step example]</title>
      <link>https://yourbasic.org/algorithms/dynamic-programming-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/dynamic-programming-explained/</guid>
      <description>Problem Recursive algorithm Dynamic programming with memoization Dynamic programming with tabulation Memoization vs. tabulation  This text contains a detailed example showing how to solve a tricky problem efficiently with recursion and dynamic programming – either with memoization or tabulation.
 A dynamic programming algorithm solves a complex problem by dividing it into simpler subproblems, solving each of those just once, and storing their solutions. Memoization is an optimization technique used to speed up programs by storing the results of expensive function calls and returning the cached result when the same inputs occur&amp;nbsp;again.</description>
    </item>
    
    <item>
      <title>Hash tables explained [step-by-step example]</title>
      <link>https://yourbasic.org/algorithms/hash-tables-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/hash-tables-explained/</guid>
      <description>Basics Hashing with chaining (simplified example) Realistic hash function example Resizing in constant amortized time  Basics Hash tables are used to implement map and set data structures in most common programming languages. In C++ and Java they are part of the standard libraries, while Python and Go have builtin dictionaries and maps.
A hash table is an unordered collection of key-value pairs, where each key is&amp;nbsp;unique.
Hash tables offer a combination of efficient lookup, insert and delete operations.</description>
    </item>
    
    <item>
      <title>How to analyze time complexity: Count your steps</title>
      <link>https://yourbasic.org/algorithms/time-complexity-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/time-complexity-explained/</guid>
      <description>Time complexity esti&amp;shy;mates the time to run an algo&amp;shy;rithm. It&#39;s calcu&amp;shy;lated by counting elemen&amp;shy;tary opera&amp;shy;tions.  Example (iterative algorithm) Worst-case time complexity Average-case time complexity Quadratic time complexity  Example (iterative algorithm) What&amp;rsquo;s the running time of the following algorithm?
 // Compute the maximum element in the array a. Algorithm max(a): max ← a[0] for i = 1 to len(a)-1 if a[i] &amp;gt; max max ← a[i] return max  The answer depends on factors such as input, programming language and runtime, coding skill, compiler, operating system, and hardware.</description>
    </item>
    
    <item>
      <title>How to avoid initializing memory [in theory]</title>
      <link>https://yourbasic.org/algorithms/avoid-initializing-memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/avoid-initializing-memory/</guid>
      <description>Consider an algorithm that uses a large memory area. If the running time of the algorithm is smaller than the size of the memory, initializing the memory will take longer than running the algorithm. However, using a shrewd trick, it’s possible to refrain from initializing the&amp;nbsp;memory.
This mysterious trick is used quite frequently in research articles, often without explanation and a reference to Exercise 2.12 in The Design and Analysis of Computer Algorithms by Aho, Hopcroft, and Ullman, 1974.</description>
    </item>
    
    <item>
      <title>Insertion sort vs. selection sort (time complexity and performance)</title>
      <link>https://yourbasic.org/algorithms/insertion-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/insertion-sort/</guid>
      <description>Insertion sort Insertion sort is a simple sorting algorithm with quadratic worst-case time complexity, but in some cases it&amp;rsquo;s still the algorithm of choice.
 It&amp;rsquo;s efficient for small data sets. It typically outperforms other simple quadratic algorithms, such as selection sort or bubble sort. It&amp;rsquo;s adaptive: it sorts data sets that are already substantially sorted efficiently. The&amp;nbsp;time complexity is O(nk) when each element is at most k&amp;nbsp;places away from its sorted position.</description>
    </item>
    
    <item>
      <title>Introduction to graph algorithms: definitions and examples</title>
      <link>https://yourbasic.org/algorithms/graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/graph/</guid>
      <description>Definitions Trees Directed graphs   Data structures Adjacency matrix Adjacency list     Search algorithms Depth-first search (DFS) Breadth-first search (BFS) Dijkstra’s algorithm       This text introduces basic graph terminology, standard graph data structures, and three fundamental algorithms for traversing a graph in a systematic&amp;nbsp;way.
You may also want to take a look at the Github yourbasic/graph repository. It&amp;rsquo;s a Go library with generic implementations of basic graph algorithms.</description>
    </item>
    
    <item>
      <title>Las Vegas vs. Monte Carlo algorithms</title>
      <link>https://yourbasic.org/algorithms/las-vegas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/las-vegas/</guid>
      <description>Zener cards A Las Vegas algorithm is a randomized algorithm that always gives the correct result but gambles with resources.
Monte Carlo simulations are a broad class of algorithms that use repeated random sampling to obtain numerical results.
 Monte Carlo simulations are typically used to simulate the behaviour of other systems. Monte Carlo algorithms, on the other hand, are randomized algorithms whose output may be incorrect with a certain, typically small, probability.</description>
    </item>
    
    <item>
      <title>Loop invariants can give you coding superpowers</title>
      <link>https://yourbasic.org/algorithms/loop-invariants-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/loop-invariants-explained/</guid>
      <description>An invariant is a state&amp;shy;ment about program vari&amp;shy;ables that is true every time the execu&amp;shy;tion of the program reaches the&amp;nbsp;invariant.
 Loop invariant definition (basic example) Designing with invariants Sorting (trickier example) 3-way partition (advanced example)  When struggling with a tricky 3-way partition algorithm as a student, a friend suggested a well-fitting invariant. It was like getting a secret superpower: suddenly I could write code that used to be impossible.</description>
    </item>
    
    <item>
      <title>O(n log log n) time integer sorting</title>
      <link>https://yourbasic.org/algorithms/fastest-sorting-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/fastest-sorting-algorithm/</guid>
      <description>The fastest sorting algorithm? The problem The algorithm Reducing number size Fast merging of short numbers    The fastest sorting algorithm?  Which sorting algorithm is the fastest? Ask this question to any group of programmers and you’ll get an animated discussion. Of course, there is no one answer. It depends not only on the algorithm, but also on the computer, data, and implementation. However, if you count the number of operations needed to sort integer numbers on a standard von Neumann computer, there is a clear winner – the algorithm presented in the paper “Sorting In Linear Time?</description>
    </item>
    
    <item>
      <title>On induction and recursive functions, with an application to binary search</title>
      <link>https://yourbasic.org/algorithms/induction-recursive-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/induction-recursive-functions/</guid>
      <description>To make sense of recursive functions, you can use a way of thinking closely related to mathematical induction.
 Mathematical induction Sum of an arithmetic series (basic example) The same sum in code Binary search correctness proof  Mathematical induction Mathematical induction is a proof method often used to prove statements about integers.
We&amp;rsquo;ll use the notation P(n), where n&amp;nbsp;&amp;ge;&amp;nbsp;0, to denote such a&amp;nbsp;statement. To prove P(n) with induction is a two-step procedure.</description>
    </item>
    
    <item>
      <title>Time complexity of array/list operations [Java, Python]</title>
      <link>https://yourbasic.org/algorithms/time-complexity-arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/time-complexity-arrays/</guid>
      <description>To write fast code, you must know the difference between constant and linear time array operations.
 Array basics Performance Dynamic array   Expensive list operations Java cheat sheet Python cheat sheet     Alternatives Maps and dictionaries Sorted arrays Linked lists Binary search trees       Accidentally inefficient list code with quadratic time complexity is very common and can be hard to&amp;nbsp;spot, but when the list grows your code grinds to a&amp;nbsp;halt.</description>
    </item>
    
    <item>
      <title>Time complexity of recursive functions [Master theorem]</title>
      <link>https://yourbasic.org/algorithms/time-complexity-recursive-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/time-complexity-recursive-functions/</guid>
      <description>It&#39;s often possible to compute the time complexity of a recursive function by formulating and solving a recurrence relation.
 Recurrence relation (basic example) Binary search Master theorem Analysis without recurrence  This text contains a few examples and a formula, the &amp;ldquo;master theorem&amp;rdquo;, which gives the solution to a class of recurrence relations that often show up when analyzing recursive functions.
We also show how to analyze recursive algorithms that depend on the size and shape of a data structure.</description>
    </item>
    
    <item>
      <title>Treaps: Randomized search trees</title>
      <link>https://yourbasic.org/algorithms/treap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/treap/</guid>
      <description>A treap stores items in sorted order and offers effi&amp;shy;cient lookup, addi&amp;shy;tion and remo&amp;shy;val of items.
If you could use only one data structure, which one would you choose? A&amp;nbsp;hash table? While it supports the basic lookup, addition and removal operations, it&amp;nbsp;doesn’t keep the elements sorted. Therefore it can’t efficiently perform some common tasks, such as finding the minimum element or producing an ordered list of all&amp;nbsp;elements.
What would you require of this ideal, sole structure?</description>
    </item>
    
    <item>
      <title>Unit cost vs. bit cost in time complexity</title>
      <link>https://yourbasic.org/algorithms/unit-cost-vs-bit-cost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/unit-cost-vs-bit-cost/</guid>
      <description>Unit-cost multiplication Unit cost and bit cost are two different cost functions used to compute space and time complexity.
 Unit cost is used in a simplified model where a number, of any size, fits within a memory cell, and where standard arithmetic operations take constant&amp;nbsp;time. With bit cost we take into account that computations with bigger numbers can be more&amp;nbsp;expensive.   Unit cost often works well in practice as modern processors can perform arithmetics on 64-bit integer and floating point numbers in constant time.</description>
    </item>
    
    <item>
      <title>What’s a seed in a random number generator?</title>
      <link>https://yourbasic.org/algorithms/random-number-generator-seed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/random-number-generator-seed/</guid>
      <description>In reality pseudo&amp;shy;random numbers aren&#39;t random at all. They are computed using a fixed determi&amp;shy;nistic algorithm.
 The seed is a starting point for a sequence of pseudorandom numbers. If you start from the same seed, you get the very same sequence. This can be quite useful for&amp;nbsp;debugging.
If you want a different sequence of numbers each time, you can use the current time as a&amp;nbsp;seed.
Example This generator produces a sequence of 97 different numbers, then it starts over again.</description>
    </item>
    
    <item>
      <title>Your basic int: a most powerful data type</title>
      <link>https://yourbasic.org/algorithms/your-basic-int/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/algorithms/your-basic-int/</guid>
      <description>The int data type is generic, effective, simple and efficient.
 Introduction Generic graph data Effective searching and sorting Simple sets Efficient filtering  Introduction Every kid can spot an integer number, and every programmer is familiar with the&amp;nbsp;int data&amp;nbsp;type. Still we frequently forget how powerful an integer can&amp;nbsp;be.
 Generic
An int or []int is a bit pattern that can represent any digital data. Furthermore, an int can point into any type of array.</description>
    </item>
    
  </channel>
</rss>