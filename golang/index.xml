<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go go-to guide on Algorithms to Go</title>
    <link>https://yourbasic.org/golang/</link>
    <description>Recent content in Go go-to guide on Algorithms to Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://yourbasic.org/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2 basic FIFO queue implementations</title>
      <link>https://yourbasic.org/golang/implement-fifo-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/implement-fifo-queue/</guid>
      <description>A simple way to implement a temporary queue data structure in Go is to use a slice:
 to enqueue you use the built-in append function, and to dequeue you slice off the first element.  var queue []string queue = append(queue, &#34;Hello &#34;) // Enqueue queue = append(queue, &#34;world!&#34;) for len(queue)  0 { fmt.Print(queue[0]) // First element queue = queue[1:] // Dequeue } Hello world! Watch out for memory leaks You may want to remove the first element before dequeuing.</description>
    </item>
    
    <item>
      <title>2 basic set implementations</title>
      <link>https://yourbasic.org/golang/implement-set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/implement-set/</guid>
      <description>Map implementation The idiomatic way to implement a set in Go is to use a&amp;nbsp;map.
set := make(map[string]bool) // New empty set set[&#34;Foo&#34;] = true // Add for k := range set { // Loop fmt.Println(k) } delete(set, &#34;Foo&#34;) // Delete size := len(set) // Size exists := set[&#34;Foo&#34;] // Membership Alternative If the memory used by the booleans is an issue, which seems unlikely, you could replace them with empty&amp;nbsp;structs.</description>
    </item>
    
    <item>
      <title>2 patterns for a do-while loop in Go</title>
      <link>https://yourbasic.org/golang/do-while-loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/do-while-loop/</guid>
      <description>There is no do-while loop in Go. To emulate the C/Java code
do { work(); } while (condition); you may use a for loop in one of these two&amp;nbsp;ways:
for ok := true; ok; ok = condition { work() } for { work() if !condition { break } } Repeat-until loop To write a repeat-until loop
repeat work(); until condition; simply change the condition in the code above to its complement:</description>
    </item>
    
    <item>
      <title>2 ways to delete an element from a slice</title>
      <link>https://yourbasic.org/golang/delete-element-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/delete-element-slice/</guid>
      <description>Fast version (changes order) a := []string{&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;} i := 2 // Remove the element at index i from a. a[i] = a[len(a)-1] // Copy last element to index i. a[len(a)-1] = &#34;&#34; // Erase last element (write zero value). a = a[:len(a)-1] // Truncate slice. fmt.Println(a) // [A B E D] The code copies a single element and runs in constant time.
Slow version (maintains order) a := []string{&#34;</description>
    </item>
    
    <item>
      <title>3 dots in 4 places</title>
      <link>https://yourbasic.org/golang/three-dots-ellipsis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/three-dots-ellipsis/</guid>
      <description>Can you name four places where three&amp;nbsp;dots (...) are used in&amp;nbsp;Go?
 Variadic function parameters If the last parameter of a function has type ...T, it can be called with any number of trailing arguments of type&amp;nbsp;T. The actual type of ...T inside the function is&amp;nbsp;[]T.
This example function can be called with, for instance, Sum(1, 2, 3) or&amp;nbsp;Sum().
func Sum(nums ...int) int { res := 0 for _, n := range nums { res += n } return res } Arguments to variadic functions You can pass a slice s directly to a variadic function if you unpack it with the s.</description>
    </item>
    
    <item>
      <title>3 rules for efficient parallel computation</title>
      <link>https://yourbasic.org/golang/efficient-parallel-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/efficient-parallel-computation/</guid>
      <description>Dividing a large compu&amp;shy;tation into work units for parallel pro&amp;shy;cessing is more of an art than a&amp;nbsp;science.
Here are three rules of&amp;nbsp;thumb.
 Divide the work into units that take about 100Î¼s to 1ms to&amp;nbsp;compute.   If&amp;nbsp;the work units are too small, the adminis&amp;shy;trative over&amp;shy;head of divi&amp;shy;ding the problem and sched&amp;shy;uling sub-problems might be too large.  If the units are too big, the whole computation may have to wait for a single slow work item to finish.</description>
    </item>
    
    <item>
      <title>3 simple ways to create an error</title>
      <link>https://yourbasic.org/golang/create-error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/create-error/</guid>
      <description>String-based errors The standard library offers two out-of-the-box options.
// simple string-based error err1 := errors.New(&#34;math: square root of negative number&#34;) // with formatting err2 := fmt.Errorf(&#34;math: square root of negative number %g&#34;, x) Custom errors with data To define a custom error type, you must satisfy the predeclared error interface.
type error interface { Error() string } Here are two examples.
type SyntaxError struct { Line int Col int } func (e *SyntaxError) Error() string { return fmt.</description>
    </item>
    
    <item>
      <title>3 ways to compare slices (arrays)</title>
      <link>https://yourbasic.org/golang/compare-slices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/compare-slices/</guid>
      <description>Basic case In most cases, you will want to write your own code to compare the elements of two&amp;nbsp;slices.
// Equal tells whether a and b contain the same elements. // A nil argument is equivalent to an empty slice. func Equal(a, b []int) bool { if len(a) != len(b) { return false } for i, v := range a { if v != b[i] { return false } } return true } For arrays, however, you can use the comparison operators == and&amp;nbsp;!</description>
    </item>
    
    <item>
      <title>3 ways to find a key in a map</title>
      <link>https://yourbasic.org/golang/check-map-contains-key/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/check-map-contains-key/</guid>
      <description>Basics When you index a map in Go you get two return values; the&amp;nbsp;second one (which is optional) is a boolean that indicates if the key&amp;nbsp;exists.
If the key doesn&amp;rsquo;t exist, the first value will be the default zero&amp;nbsp;value.
Check second return value m := map[string]float64{&#34;pi&#34;: 3.14} v, found := m[&#34;pi&#34;] // v == 3.14 found == true v, found = m[&#34;pie&#34;] // v == 0.0 found == false _, found = m[&#34;</description>
    </item>
    
    <item>
      <title>3 ways to split a string into a slice</title>
      <link>https://yourbasic.org/golang/split-string-into-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/split-string-into-slice/</guid>
      <description>Split on comma or other substring Split by whitespace and newline Split on regular expression  Split on comma or other substring Use the strings.Split function to split a string into its comma separated values.
s := strings.Split(&amp;#34;a,b,c&amp;#34;, &amp;#34;,&amp;#34;) fmt.Println(s) // Output: [a b c] To include the separators, use strings.SplitAfter. To split only the first n values, use strings.SplitN and strings.SplitAfterN.
You can use strings.TrimSpace to strip leading and trailing whitespace from the resulting strings.</description>
    </item>
    
    <item>
      <title>3 ways to trim whitespace (or other characters) from a string</title>
      <link>https://yourbasic.org/golang/trim-whitespace-from-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/trim-whitespace-from-string/</guid>
      <description>Use the strings.TrimSpace function to remove leading and trailing whitespace as defined by&amp;nbsp;Unicode.
s := strings.TrimSpace(&#34;\t Goodbye hair!\n &#34;) fmt.Printf(&#34;%q&#34;, s) // &#34;Goodbye hair!&#34;  To remove other leading and trailing characters, use strings.Trim. To remove only the leading or the trailing characters, use strings.TrimLeft or strings.TrimRight.  Further reading 
40+ practical string tips [cheat sheet]</description>
    </item>
    
    <item>
      <title>4 basic if-else statement patterns</title>
      <link>https://yourbasic.org/golang/if-else-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/if-else-statement/</guid>
      <description>Basic syntax With init statement Nested if statements Ternary ? operator alternatives  Basic syntax if x  max { x = max } if x { min = x } else { min = y } An if statement executes one of two branches according to a boolean expression.
 If the expression evaluates to true, the if branch is executed, otherwise, if present, the else branch is executed.</description>
    </item>
    
    <item>
      <title>4 basic range loop (for-each) patterns</title>
      <link>https://yourbasic.org/golang/for-loop-range-array-slice-map-channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/for-loop-range-array-slice-map-channel/</guid>
      <description>Basic for-each loop (slice or array) String iteration: runes or bytes Map iteration: keys and values Channel iteration Gotchas  Basic for-each loop (slice or array) a := []string{&#34;Foo&#34;, &#34;Bar&#34;} for i, s := range a { fmt.Println(i, s) } 0 Foo 1 Bar  The range expression, a, is evaluated once before beginning the loop. The iteration values are assigned to the respective iteration variables, i and s, as in an assignment statement.</description>
    </item>
    
    <item>
      <title>4 iota enum examples</title>
      <link>https://yourbasic.org/golang/iota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/iota/</guid>
      <description>Iota basic example Start from one Skip value  Complete enum type with strings Naming convention   Iota basic example  The iota keyword represents successive integer constants 0, 1, 2,â¦ It resets to 0 whenever the word const appears in the source code, and increments after each const specification.  const ( C0 = iota C1 = iota C2 = iota ) fmt.Println(C0, C1, C2) // &#34;</description>
    </item>
    
    <item>
      <title>5 basic for loop patterns</title>
      <link>https://yourbasic.org/golang/for-loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/for-loop/</guid>
      <description>A for statement is used to execute a block of code repeatedly.
 Three-component loop While loop Infinite loop For-each range loop Exit a loop  Three-component loop This version of the Go for loop works just as in C or&amp;nbsp;Java.
sum := 0 for i := 1; i { sum += i } fmt.Println(sum) // 10 (1+2+3+4)  The init statement, i := 1, runs. The condition, i &amp;lt; 5, is computed.</description>
    </item>
    
    <item>
      <title>5 switch statement patterns</title>
      <link>https://yourbasic.org/golang/switch-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/switch-statement/</guid>
      <description>Basic switch with default No condition Case list Fallthrough Exit with break Execution order  Basic switch with default  A switch statement runs the first case equal to the condition expression. The cases are evaluated from top to bottom, stopping when a case succeeds. If no case matches and there is a default case, its statements are executed.  switch time.Now().Weekday() { case time.Saturday: fmt.Println(&#34;Today is Saturday.&#34;) case time.</description>
    </item>
    
    <item>
      <title>A basic stack (LIFO) data structure</title>
      <link>https://yourbasic.org/golang/implement-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/implement-stack/</guid>
      <description>The idiomatic way to implement a stack data structure in Go is to use a slice:
 to push you use the built-in append function, and to pop you slice off the top element.  var stack []string stack = append(stack, &#34;world!&#34;) // Push stack = append(stack, &#34;Hello &#34;) for len(stack)  0 { n := len(stack) - 1 // Top element fmt.Print(stack[n]) stack = stack[:n] // Pop } Hello world!</description>
    </item>
    
    <item>
      <title>A panic is an exception in Go</title>
      <link>https://yourbasic.org/golang/panic-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/panic-explained/</guid>
      <description>See Recover from a panic [best practices].</description>
    </item>
    
    <item>
      <title>Access environment variables</title>
      <link>https://yourbasic.org/golang/environment-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/environment-variables/</guid>
      <description> Use the os.Setenv, os.Getenv and os.Unsetenv functions to access environment variables.
fmt.Printf(&#34;%q\n&#34;, os.Getenv(&#34;SHELL&#34;)) // &#34;/bin/bash&#34; os.Unsetenv(&#34;SHELL&#34;) fmt.Printf(&#34;%q\n&#34;, os.Getenv(&#34;SHELL&#34;)) // &#34;&#34; os.Setenv(&#34;SHELL&#34;, &#34;/bin/dash&#34;) fmt.Printf(&#34;%q\n&#34;, os.Getenv(&#34;SHELL&#34;)) // &#34;/bin/dash&#34; The os.Environ function returns a slice of &amp;quot;key=value&amp;quot; strings listing all environment variables.
for _, s := range os.Environ() { kv := strings.SplitN(s, &#34;=&#34;, 2) // unpacks &#34;key=value&#34; fmt.Printf(&#34;key:%q value:%q\n&#34;, kv[0], kv[1]) } key:&amp;#34;SHELL&amp;#34; value:&amp;#34;/bin/bash&amp;#34; key:&amp;#34;SESSION&amp;#34; value:&amp;#34;ubuntu&amp;#34; key:&amp;#34;TERM&amp;#34; value:&amp;#34;xterm-256color&amp;#34; key:&amp;#34;LANG&amp;#34; value:&amp;#34;en_US.UTF-8&amp;#34; key:&amp;#34;XMODIFIERS&amp;#34; value:&amp;#34;@im=ibus&amp;#34; â¦</description>
    </item>
    
    <item>
      <title>Access private fields with reflection</title>
      <link>https://yourbasic.org/golang/access-private-field-reflection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/access-private-field-reflection/</guid>
      <description>With reflection it&#39;s possible to read, but not write, unexported fields of a struct defined in another package.
 In this example, we access the unexported field len in the List struct in package container/list:
package list type List struct { root Element len int } This code reads the value of len with reflection.
package main import ( &#34;container/list&#34; &#34;fmt&#34; &#34;reflect&#34; ) func main() { l := list.New() l.PushFront(&#34;foo&#34;) l.</description>
    </item>
    
    <item>
      <title>Anonymous functions and closures</title>
      <link>https://yourbasic.org/golang/anonymous-function-literal-lambda-closure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/anonymous-function-literal-lambda-closure/</guid>
      <description>A function literal (or lambda) is a&amp;nbsp;function without a&amp;nbsp;name.
 In this example a function literal is passed as the less argument to the sort.Slice function.
func Slice(slice interface{}, less func(i, j int) bool)  people := []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Dave&#34;} sort.Slice(people, func(i, j int) bool { return len(people[i]) ) fmt.Println(people) // Output: [Bob Dave Alice] You can also use an intermediate variable.
people := []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Dave&#34;} less := func(i, j int) bool { return len(people[i]) sort.</description>
    </item>
    
    <item>
      <title>Append text to a file</title>
      <link>https://yourbasic.org/golang/append-to-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/append-to-file/</guid>
      <description>This code appends a line of text to the file text.log. It creates the file if it doesn&amp;rsquo;t already&amp;nbsp;exist.
f, err := os.OpenFile(&amp;#34;text.log&amp;#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Println(err) } defer f.Close() if _, err := f.WriteString(&amp;#34;text to append\n&amp;#34;); err != nil { log.Println(err) } If you&amp;rsquo;re appending text to a file for logging purposes, see Write log to file.</description>
    </item>
    
    <item>
      <title>Array wonât change</title>
      <link>https://yourbasic.org/golang/gotcha-function-doesnt-change-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-function-doesnt-change-array/</guid>
      <description>Why does the array value stick?
func Foo(a [2]int) { a[0] = 8 } func main() { a := [2]int{1, 2} Foo(a) // Try to change a[0]. fmt.Println(a) // Output: [1 2] } Answer  Arrays in Go are values. When you pass an array to a function, the array is copied.  If you want Foo to update the elements of&amp;nbsp;a, use a slice instead.
func Foo(a []int) { if len(a)  0 { a[0] = 8 } } func main() { a := []int{1, 2} Foo(a) // Change a[0].</description>
    </item>
    
    <item>
      <title>Assignment to entry in nil map</title>
      <link>https://yourbasic.org/golang/gotcha-assignment-entry-nil-map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-assignment-entry-nil-map/</guid>
      <description>Why does this program panic?
var m map[string]float64 m[&#34;pi&#34;] = 3.1416 panic: assignment to entry in nil map Answer You have to initialize the map using the make function (or a map literal) before you can add any elements:
m := make(map[string]float64) m[&#34;pi&#34;] = 3.1416 See Maps explained for more about maps.</description>
    </item>
    
    <item>
      <title>Binary search: take a sortcut [sic]</title>
      <link>https://yourbasic.org/golang/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/binary-search/</guid>
      <description>See How to find an element in a slice/array.</description>
    </item>
    
    <item>
      <title>Bitmasks, bitsets and flags</title>
      <link>https://yourbasic.org/golang/bitmask-flag-set-clear/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/bitmask-flag-set-clear/</guid>
      <description>Bitmask A bitmask is a small set of booleans, often called flags, represented by the bits in a single number.
type Bits uint8 const ( F0 Bits = 1  0 true 1 false 2 true Larger bitsets To represent larger sets of bits, you may want to use a custom data structure. The package github.com/yourbasic/bit provides a bit array implementation and some utility bit functions.
Because a bit array uses bit-level parallelism, limits memory access, and efficiently uses the data cache, it often outperforms other data structures.</description>
    </item>
    
    <item>
      <title>Bitwise operators [cheat sheet]</title>
      <link>https://yourbasic.org/golang/bitwise-operator-cheat-sheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/bitwise-operator-cheat-sheet/</guid>
      <description>Gottfried Wilhelm Leibniz, 1697 Number literals Built-in operators Package math/bits Bit manipulation code example  Number literals The binary number 100002 can be written as 020, 16 or 0x10 in&amp;nbsp;Go.
  Literal Base Note     020 8 Starts with&amp;nbsp;0   16 10 Never starts with&amp;nbsp;0   0x10 16 Starts with&amp;nbsp;0x    &amp;nbsp;
Built-in operators   Operation Result Description     0011 &amp;amp; 0101 0001 Bitwise AND   0011 | 0101 0111 Bitwise OR   0011 ^ 0101 0110 Bitwise XOR   ^0101 1010 Bitwise NOT (same as 1111&amp;nbsp;^&amp;nbsp;0101)   0011 &amp;amp;^ 0101 0010 Bitclear (AND&amp;nbsp;NOT)   00110101&amp;lt;&amp;lt;2 11010100 Left shift   00110101&amp;lt;&amp;lt;100 00000000 No upper limit on shift count   00110101&amp;gt;&amp;gt;2 00001101 Right shift     The binary numbers in the examples are for explanation only.</description>
    </item>
    
    <item>
      <title>Blank identifier (underscore)</title>
      <link>https://yourbasic.org/golang/underscore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/underscore/</guid>
      <description>The blank identifier _ is an anonymous placeholder. It may be used like any other identifier in a declaration, but it does not introduce a binding.
Ignore values The blank identifier provides a way to ignore left-hand side values in an assignment.
_, present := timeZone[&amp;#34;CET&amp;#34;] sum := 0 for _, n := range a { sum += n } Import for side effects It can also be used to import a package solely for its side effects.</description>
    </item>
    
    <item>
      <title>Broadcast a signal on a channel</title>
      <link>https://yourbasic.org/golang/broadcast-channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/broadcast-channel/</guid>
      <description>All readers receive zero&amp;nbsp;values on a closed channel.
In this example the Publish function returns a channel, which is used to broadcast a signal when a message has been published.
// Print text after the given time has expired. // When done, the wait channel is closed. func Publish(text string, delay time.Duration) (wait close(ch) // Broadcast to all receivers. }() return ch } Notice that we use a channel of empty structs: struct{}.</description>
    </item>
    
    <item>
      <title>Canât change entries in range loop</title>
      <link>https://yourbasic.org/golang/gotcha-change-value-range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-change-value-range/</guid>
      <description>Why isn&amp;rsquo;t the slice updated in this example?
s := []int{1, 1, 1} for _, n := range s { n += 1 } fmt.Println(s) // Output: [1 1 1] Answer The range loop copies the values from the slice to a local variable n; updating n will not affect the&amp;nbsp;slice.
Update the slice entries like this:
s := []int{1, 1, 1} for i := range s { s[i] += 1 } fmt.</description>
    </item>
    
    <item>
      <title>Channels offer synchronized communication</title>
      <link>https://yourbasic.org/golang/channels-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/channels-explained/</guid>
      <description>A&amp;nbsp;channel is a mechanism for goroutines to synchronize execution and communicate by passing values.
A new channel value can be made using the built-in function make.
// unbuffered channel of ints ic := make(chan int) // buffered channel with room for 10 strings sc := make(chan string, 10) To send a value on a channel, use &amp;lt;- as a binary operator. To receive a value on a channel, use it as a unary operator.</description>
    </item>
    
    <item>
      <title>Check if a number is prime</title>
      <link>https://yourbasic.org/golang/check-prime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/check-prime/</guid>
      <description>Sacks spiral of prime numbers Ints For integer types, use ProbablyPrime(0) from package math/big. This primality test is 100%&amp;nbsp;accurate for inputs less than&amp;nbsp;264.
const n = 1212121 if big.NewInt(n).ProbablyPrime(0) { fmt.Println(n, &#34;is prime&#34;) } else { fmt.Println(n, &#34;is not prime&#34;) } 1212121 is prime Larger numbers  For larger numbers, you need to provide the desired number of tests to ProbablyPrime(n). For n&amp;nbsp;tests, the&amp;nbsp;probability of returning true for a randomly chosen non-prime is at most (1/4)n.</description>
    </item>
    
    <item>
      <title>Command-line arguments and flags</title>
      <link>https://yourbasic.org/golang/command-line-arguments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/command-line-arguments/</guid>
      <description>The os.Args variable holds the command-line arguments â starting with the program name â which are passed to a Go program.
func main() { if len(os.Args) != 3 { fmt.Println(&#34;Usage:&#34;, os.Args[0], &#34;PATTERN&#34;, &#34;FILE&#34;) return } pattern := os.Args[1] file := os.Args[2] // ... } $ go build grep.go $ ./grep Usage: ./grep PATTERN FILE Flag parsing The flag package implements basic command-line flag parsing.</description>
    </item>
    
    <item>
      <title>Compute absolute value of an int/float</title>
      <link>https://yourbasic.org/golang/absolute-value-int-float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/absolute-value-int-float/</guid>
      <description>Integers There is no built-in abs function for integers, but it&amp;rsquo;s simple to write your&amp;nbsp;own.
// Abs returns the absolute value of x. func Abs(x int64) int64 { if x &amp;lt; 0 { return -x } return x } Warning: The smallest value of a signed integer doesnât have a matching positive value.  math.MinInt64 is -9223372036854775808, but math.MaxInt64 is 9223372036854775807.  Unfortunately, our Abs function returns a negative value in this case.</description>
    </item>
    
    <item>
      <title>Compute max of two ints/floats</title>
      <link>https://yourbasic.org/golang/max-min-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/max-min-function/</guid>
      <description>Integers There is no built-in max or min function for integers, but it&amp;rsquo;s simple to write your&amp;nbsp;own.
// Max returns the larger of x or y. func Max(x, y int64) int64 { if x y { return y } return x }  Floats For floats, use math.Max and math.Min.
// Max returns the larger of x or y. func Max(x, y float64) float64 // Min returns the smaller of x or y.</description>
    </item>
    
    <item>
      <title>Concurrent programming</title>
      <link>https://yourbasic.org/golang/concurrent-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/concurrent-programming/</guid>
      <description>This tutorial covers the funda&amp;shy;mentals of concurrent programming with examples in&amp;nbsp;Go.
 Before you start, you need to know how to write basic Go programs. If you need a refresher, the&amp;nbsp;resources in this Go beginnerâs guide will help you come up to speed quickly with&amp;nbsp;Go.
Letâs start
Table of contents </description>
    </item>
    
    <item>
      <title>Constant overflows int</title>
      <link>https://yourbasic.org/golang/gotcha-constant-overflows-int/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-constant-overflows-int/</guid>
      <description>Why doesn&amp;rsquo;t this code compile?
const n = 9876543210 * 9876543210 fmt.Println(n) ../main.go:2:13: constant 97546105778997104100 overflows int Answer The untyped constant n must be converted to a type before it can be assigned to the interface{} parameter in the call to fmt.Println.
fmt.Println(a ...interface{}) When the type canât be inferred from the context, an untyped constant is converted to a bool, int, float64, complex128, string or rune depending of the format of the&amp;nbsp;constant.</description>
    </item>
    
    <item>
      <title>Constructors deconstructed [best practice]</title>
      <link>https://yourbasic.org/golang/constructor-best-practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/constructor-best-practice/</guid>
      <description>Go doesn&#39;t have explicit constructors. The idiomatic way to set up new data structures is to use proper zero values coupled with factory functions.
 Zero value Try to make the default zero value useful and document its behavior. Sometimes this is all that&amp;rsquo;s needed.
// A StopWatch is a simple clock utility. // Its zero value is an idle clock with 0 total time. type StopWatch struct { start time.</description>
    </item>
    
    <item>
      <title>Conversions [complete list]</title>
      <link>https://yourbasic.org/golang/conversions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/conversions/</guid>
      <description>Basics Interfaces Integers Floats Integer to string Strings and byte slices Strings and rune slices Underlying type Implicit conversions Pointers   Basics The expression T(x) converts the value x to the type&amp;nbsp;T.
x := 5.1 n := int(x) // convert float to int The conversion rules are extensive but predictable:
 all conversions between typed expressions must be explicitly stated, illegal conversions are caught by the compiler.  Conversions to and from numbers and strings may change the representation and have a run-time cost.</description>
    </item>
    
    <item>
      <title>Convert between byte array/slice and string</title>
      <link>https://yourbasic.org/golang/convert-string-to-byte-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/convert-string-to-byte-slice/</guid>
      <description>Basics Convert string to bytes Convert bytes to string Performance  Basics When you convert between a string and a byte slice (array), you get a brand new slice that contains the same bytes as the string, and vice versa.
 The conversion doesn&amp;rsquo;t change the data; the only difference is that strings are immutable, while byte slices can be modified.   If you need to manipulate the characters (runes) of a string, you may want to convert the string to a rune slice instead.</description>
    </item>
    
    <item>
      <title>Convert between float and string</title>
      <link>https://yourbasic.org/golang/convert-string-to-float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/convert-string-to-float/</guid>
      <description>3.141592653589793238462643383279 5028841971693993751058209749445923 07816406286208998628034825342117067 9821 48086 5132 823 06647 09384 46 09550 58223 17 25359 4081 2848 1117 4502 8410 2701 9385 21105 55964 46229 48954 9303 81964 4288 10975 66593 34461 284756 48233 78678 31652 71 2019091 456485 66 9234603 48610454326648 2133936 0726024914127 3724587 00660631558 817488 152092096  String to float Use the strconv.ParseFloat function to parse a string as a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64.</description>
    </item>
    
    <item>
      <title>Convert between int, int64 and string</title>
      <link>https://yourbasic.org/golang/convert-int-to-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/convert-int-to-string/</guid>
      <description>int/int64 to string string to int/int64 int to int64 (and back) General formatting (width, indent, sign)  int/int64 to string Use strconv.Itoa to convert an int to a decimal string.
s := strconv.Itoa(97) // s == &#34;97&#34; Warning: In a plain conversion the value is interpreted as a Unicode code point, and the resulting string will contain the character represented by that code point, encoded in UTF-8. s := string(97) // s == &#34;</description>
    </item>
    
    <item>
      <title>Convert between rune array/slice and string</title>
      <link>https://yourbasic.org/golang/convert-string-to-rune-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/convert-string-to-rune-slice/</guid>
      <description>Convert string to runes Convert runes to string Performance  Convert string to runes  When you convert a string to a rune slice, you get a new slice that contains the Unicode code points (runes) of the&amp;nbsp;string. For an invalid UTF-8 sequence, the rune value will be 0xFFFD for each invalid&amp;nbsp;byte.  r := []rune(&#34;ABCâ¬&#34;) fmt.Println(r) // [65 66 67 8364] fmt.Printf(&#34;%U\n&#34;, r) // [U+0041 U+0042 U+0043 U+20AC]   You can also use a range loop to access the code points of a string.</description>
    </item>
    
    <item>
      <title>Convert interface to string</title>
      <link>https://yourbasic.org/golang/interface-to-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/interface-to-string/</guid>
      <description>Use fmt.Sprintf to convert an interface value to a string.
var x interface{} = &amp;#34;abc&amp;#34; str := fmt.Sprintf(&amp;#34;%v&amp;#34;, x) In fact, the same technique can be used to get a string representation of any data structure.
var x interface{} = []int{1, 2, 3} str := fmt.Sprintf(&#34;%v&#34;, x) fmt.Println(str) // &#34;[1 2 3]&#34; Fmt cheat sheet  Top fmt formatting tips</description>
    </item>
    
    <item>
      <title>Convert string to int/int64</title>
      <link>https://yourbasic.org/golang/convert-string-to-int/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/convert-string-to-int/</guid>
      <description>See Convert between int/int64 and string.</description>
    </item>
    
    <item>
      <title>Create a new image</title>
      <link>https://yourbasic.org/golang/create-image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/create-image/</guid>
      <description>Use the image, image/color, and image/png packages to create a&amp;nbsp;PNG&amp;nbsp;image.
width := 200 height := 100 upLeft := image.Point{0, 0} lowRight := image.Point{width, height} img := image.NewRGBA(image.Rectangle{upLeft, lowRight}) // Colors are defined by Red, Green, Blue, Alpha uint8 values. cyan := color.RGBA{100, 200, 200, 0xff} // Set color for each pixel. for x := 0; x // upper left quadrant img.Set(x, y, cyan) case x = width/2 &amp;&amp; y = height/2: // lower right quadrant img.</description>
    </item>
    
    <item>
      <title>Create a temporary file or directory</title>
      <link>https://yourbasic.org/golang/temporary-file-directory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/temporary-file-directory/</guid>
      <description>File Use ioutil.TempFile in package io/ioutil to create a globally unique temporary file. Itâs your own job to remove the file when itâs no longer needed.
file, err := ioutil.TempFile(&#34;dir&#34;, &#34;prefix&#34;) if err != nil { log.Fatal(err) } defer os.Remove(file.Name()) fmt.Println(file.Name()) // For example &#34;dir/prefix054003078&#34; The call to ioutil.TempFile
 creates a new file with a name starting with &amp;quot;prefix&amp;quot; in the directory &amp;quot;dir&amp;quot;, opens the file for reading and writing, and returns the new *os.</description>
    </item>
    
    <item>
      <title>Create, initialize and compare structs</title>
      <link>https://yourbasic.org/golang/structs-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/structs-explained/</guid>
      <description>Struct types 2 ways to create and initialize a new struct Compare structs  Struct types A struct is a typed collection of fields, useful for grouping data into records.
type Student struct { Name string Age int } var a Student // a == Student{&#34;&#34;, 0} a.Name = &#34;Alice&#34; // a == Student{&#34;Alice&#34;, 0}   To define a new struct type, you list the names and types of each field.</description>
    </item>
    
    <item>
      <title>Data races explained</title>
      <link>https://yourbasic.org/golang/data-races-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/data-races-explained/</guid>
      <description>A&amp;nbsp;data&amp;nbsp;race happens when two goroutines access the same variable concur&amp;shy;rently, and at least one of the accesses is a&amp;nbsp;write.
Data races are quite common and can be very hard to debug.
This function has a data race and itâs behavior is undefined. It may, for example, print the number&amp;nbsp;1. Try to figure out how that can happen â one possible explanation comes after the&amp;nbsp;code.
func race() { wait := make(chan struct{}) n := 0 go func() { n++ // read, increment, write close(wait) }() n++ // conflicting access // Output: &amp;lt;unspecified&amp;gt; } The two goroutines, g1 and g2, participate in a race and there is no way to know in which order the operations will take place.</description>
    </item>
    
    <item>
      <title>Days between two dates</title>
      <link>https://yourbasic.org/golang/days-between-dates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/days-between-dates/</guid>
      <description> func main() { // The leap year 2016 had 366 days. t1 := Date(2016, 1, 1) t2 := Date(2017, 1, 1) days := t2.Sub(t1).Hours() / 24 fmt.Println(days) // 366 } func Date(year, month, day int) time.Time { return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.UTC) } </description>
    </item>
    
    <item>
      <title>Days in a month</title>
      <link>https://yourbasic.org/golang/last-day-month-date/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/last-day-month-date/</guid>
      <description>To compute the last day of a month, you can use the fact that time.Date accepts values outside their usual ranges &amp;ndash; the values are normalized during the conversion.
To compute the number of days in February, look at the day before March&amp;nbsp;1.
func main() { t := Date(2000, 3, 0) // the day before 2000-03-01 fmt.Println(t) // 2000-02-29 00:00:00 +0000 UTC fmt.Println(t.Day()) // 29 } func Date(year, month, day int) time.</description>
    </item>
    
    <item>
      <title>Default zero values for all Go types</title>
      <link>https://yourbasic.org/golang/default-zero-value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/default-zero-value/</guid>
      <description>Variables declared without an initial value are set to their zero&amp;nbsp;values:
 0 for all integer types, 0.0 for floating point numbers, false for booleans, &amp;quot;&amp;quot; for strings, nil for interfaces, slices, channels, maps, pointers and functions.  The elements of an array or struct will have its fields zeroed if no value is specified. This initialization is done recursively:
type T struct { n int f float64 next *T } fmt.</description>
    </item>
    
    <item>
      <title>Defer a function call (with return value)</title>
      <link>https://yourbasic.org/golang/defer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/defer/</guid>
      <description>Defer statement basics Order of execution Use func to return a value   Common applications Close a file Error handling: catch a panic    Defer statement basics A defer statement postpones the execution of a function until the surrounding function returns, either normally or through a&amp;nbsp;panic.
func main() { defer fmt.Println(&#34;World&#34;) fmt.Println(&#34;Hello&#34;) } Hello World Deferred calls are executed even when the function panics:
func main() { defer fmt.</description>
    </item>
    
    <item>
      <title>Do you make these Go coding mistakes?</title>
      <link>https://yourbasic.org/golang/gotcha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha/</guid>
      <description> This collection of Go gotchas and pitfalls will help you find and fix similar problems in your own&amp;nbsp;code.
Some of the puzzles are pretty easy. To solve all 27, you have to be a&amp;nbsp;ninja.
Letâs start
Go Gotchas </description>
    </item>
    
    <item>
      <title>Efficient string concatenation [full guide]</title>
      <link>https://yourbasic.org/golang/build-append-concatenate-strings-efficiently/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/build-append-concatenate-strings-efficiently/</guid>
      <description>Clean and simple string building (fmt) High-performance string concatenation (stringbuilder) Before Go 1.10 (bytebuffer)  Clean and simple string building For simple cases where performance is a non-issue, fmt.Sprintf is your friend. It&amp;rsquo;s clean, simple and fairly efficient.
s := fmt.Sprintf(&#34;Size: %d MB.&#34;, 85) // s == &#34;Size: 85 MB.&#34; The fmt cheat sheet lists the most common formatting verbs and flags.
High-performance string concatenationGo&amp;nbsp;1.10 A strings.Builder is used to efficiently append strings using write&amp;nbsp;methods.</description>
    </item>
    
    <item>
      <title>Enum with String function</title>
      <link>https://yourbasic.org/golang/define-enumeration-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/define-enumeration-string/</guid>
      <description>See iota enum examples.</description>
    </item>
    
    <item>
      <title>Error handling best practice</title>
      <link>https://yourbasic.org/golang/errors-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/errors-explained/</guid>
      <description>Go has two different error-handling mechanisms:
 most functions return errors; only a truly unrecoverable condition, such as an out-of-range index, produces a run-time exception, known as a panic.  Goâs multivalued return makes it easy to return a detailed error message alongside the normal return value. By convention, such messages have type error, a simple built-in interface:
type error interface { Error() string } Error handling example The os.</description>
    </item>
    
    <item>
      <title>Escapes and multiline strings</title>
      <link>https://yourbasic.org/golang/multiline-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/multiline-string/</guid>
      <description>Raw string literals Backtick escape   Interpreted string literals Double quote escape   Escape HTML Escape URL All escape characters  Raw string literals Raw string literals, delimited by backticks (back quotes), are interpreted literally. They can contain line breaks, and backslashes have no special meaning.
const s = `First line Second line` fmt.Println(s) First line Second line Backtick escape It&amp;rsquo;s not possible to include a backtick in a raw string literal, but you can do</description>
    </item>
    
    <item>
      <title>Find current working directory</title>
      <link>https://yourbasic.org/golang/current-directory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/current-directory/</guid>
      <description>Current directory Use os.Getwd to find the path name for the current directory.
path, err := os.Getwd() if err != nil { log.Println(err) } fmt.Println(path) // for example /home/user Warning: If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.  Current executable Use os.Executable to find the path name for the executable that started the current process.</description>
    </item>
    
    <item>
      <title>Find element in slice/array with linear or binary search</title>
      <link>https://yourbasic.org/golang/find-search-contains-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/find-search-contains-slice/</guid>
      <description>Linear search Binary search The map option  Linear search Go doesn&amp;rsquo;t have an out-of-the-box linear search function for slices and arrays. Here are two example linear&amp;nbsp;search implemen&amp;shy;tations, which you can use as templates.
// Find returns the smallest index i at which x == a[i], // or len(a) if there is no such index. func Find(a []string, x string) int { for i, n := range a { if x == n { return i } } return len(a) } // Contains tells whether a contains x.</description>
    </item>
    
    <item>
      <title>Find the type of an object</title>
      <link>https://yourbasic.org/golang/find-type-of-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/find-type-of-object/</guid>
      <description>Use fmt for a string type description You can use the %T flag in the fmt package to get a Go-syntax representation of the&amp;nbsp;type.
var x interface{} = []int{1, 2, 3} xType := fmt.Sprintf(&#34;%T&#34;, x) fmt.Println(xType) // &#34;[]int&#34; (The empty interface denoted by interface{} can hold values of any type.)
A type switch lets you choose between types Use a type switch to do several type assertions in series.</description>
    </item>
    
    <item>
      <title>fmt.Printf formatting tutorial and cheat sheet</title>
      <link>https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/</guid>
      <description>Basics Printf Sprintf (format without printing) Find fmt errors with vet   Cheat sheet Default formats and type Integer (indent, base, sign) Character (quoted, Unicode) Boolean (true/false) Pointer (hex) Float (indent, precision, scientific notation) String or byte slice (quote, indent, hex) Special values    Basics With the Go fmt package you can format numbers and strings padded with spaces or zeroes, in different bases, and with optional quotes.</description>
    </item>
    
    <item>
      <title>Format a time or date [complete guide]</title>
      <link>https://yourbasic.org/golang/format-parse-string-time-date-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/format-parse-string-time-date-example/</guid>
      <description>Basic example Standard time and date formats Layout options Corner cases  Basic example Go doesn&amp;rsquo;t use yyyy-mm-dd layout to format a time. Instead, you format a special layout parameter
Mon Jan 2 15:04:05 MST 2006
the same way as the time or date should be formatted. (This date is easier to remember when written as 01/02&amp;nbsp;03:04:05PM&amp;nbsp;&amp;lsquo;06&amp;nbsp;-0700.)
const ( layoutISO = &#34;2006-01-02&#34; layoutUS = &#34;January 2, 2006&#34; ) date := &#34;</description>
    </item>
    
    <item>
      <title>Format byte size as kilobytes, megabytes, gigabytes, ...</title>
      <link>https://yourbasic.org/golang/formatting-byte-size-to-human-readable-format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/formatting-byte-size-to-human-readable-format/</guid>
      <description>These utility functions convert a size in bytes to a human-readable string in either SI&amp;nbsp;(decimal) or IEC&amp;nbsp;(binary) format.
  Input ByteCountSI ByteCountIEC     999 &#34;999&amp;nbsp;B&#34; &#34;999&amp;nbsp;B&#34;   1000 &#34;1.0&amp;nbsp;kB&#34; &#34;1000&amp;nbsp;B&#34;   1023 &#34;1.0&amp;nbsp;kB&#34; &#34;1023&amp;nbsp;B&#34;   1024 &#34;1.0&amp;nbsp;kB&#34; &#34;1.0&amp;nbsp;KiB&#34;   987,654,321 &#34;987.7&amp;nbsp;MB&#34; &#34;941.9&amp;nbsp;MiB&#34;   math.MaxInt64 &#34;9.2&amp;nbsp;EB&#34; &#34;8.0&amp;nbsp;EiB&#34;    
func ByteCountSI(b int64) string { const unit = 1000 if b = unit; n /= unit { div *= unit exp++ } return fmt.</description>
    </item>
    
    <item>
      <title>Function types and values</title>
      <link>https://yourbasic.org/golang/function-pointer-type-declaration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/function-pointer-type-declaration/</guid>
      <description>Function types and function values can be used and passed around just like other&amp;nbsp;values:
type Operator func(x float64) float64 // Map applies op to each element of a. func Map(op Operator, a []float64) []float64 { res := make([]float64, len(a)) for i, x := range a { res[i] = op(x) } return res } func main() { op := math.Abs a := []float64{1, -2} b := Map(op, a) fmt.Println(b) // [1 2] c := Map(func(x float64) float64 { return 10 * x }, b) fmt.</description>
    </item>
    
    <item>
      <title>Functional programming in Go [case study]</title>
      <link>https://yourbasic.org/golang/your-basic-func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/your-basic-func/</guid>
      <description>A graph implementation based entirely on functions
 The Petersen graph and its complement Introduction This text is about the implementation of a Go tool based entirely on functions â the API contains only immutable data types, and the code is built on top of a struct with five func fields.
It&amp;rsquo;s a tool for building virtual graphs. In a virtual graph no vertices or edges are stored in memory, they are instead computed as needed.</description>
    </item>
    
    <item>
      <title>Generate a random string (password)</title>
      <link>https://yourbasic.org/golang/generate-random-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/generate-random-string/</guid>
      <description>Random string This code generates a random string of numbers and characters from the Swedish alphabet (which includes the non-ASCII characters Ã¥, Ã¤ and Ã¶).
rand.Seed(time.Now().UnixNano()) chars := []rune(&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZÃÃÃ&#34; + &#34;abcdefghijklmnopqrstuvwxyzÃ¥Ã¤Ã¶&#34; + &#34;0123456789&#34;) length := 8 var b strings.Builder for i := 0; i // E.g. &#34;ExcbsVQs&#34;  Warning: To generate a password, you should use cryptographically secure pseudorandom numbers. See User-friendly access to crypto/rand.  Random string with restrictions This code generates a random ASCII string with at least one digit and one special character.</description>
    </item>
    
    <item>
      <title>Generate a unique string (UUID, GUID)</title>
      <link>https://yourbasic.org/golang/generate-uuid-guid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/generate-uuid-guid/</guid>
      <description>A universally unique identifier (UUID), or globally unique identifier (GUID), is a 128-bit number used to identify information.
 A UUID is for practical purposes unique: the probability that it will be duplicated is very close to zero. UUIDs don&amp;rsquo;t depend on a central authority or on coordination between those generating them.  The string representation of a UUID consists of 32 hexadecimal digits displayed in 5&amp;nbsp;groups separated by hyphens.</description>
    </item>
    
    <item>
      <title>Generate all permutations</title>
      <link>https://yourbasic.org/golang/generate-permutation-slice-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/generate-permutation-slice-string/</guid>
      <description> // Perm calls f with each permutation of a. func Perm(a []rune, f func([]rune)) { perm(a, f, 0) } // Permute the values at index i to len(a)-1. func perm(a []rune, f func([]rune), i int) { if i  len(a) { f(a) return } perm(a, f, i+1) for j := i + 1; j  Example usage:
Perm([]rune(&amp;#34;abc&amp;#34;), func(a []rune) { fmt.Println(string(a)) }) Output:
abc acb bac bca cba cab</description>
    </item>
    
    <item>
      <title>Generate random numbers, characters and slice elements</title>
      <link>https://yourbasic.org/golang/generate-number-random-range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/generate-number-random-range/</guid>
      <description>Go pseudo-random number basics Several random sources   Integers and characters in a given range Number between a and b Character between a and z   Random element from slice  Go pseudo-random number basics Use the rand.Seed and rand.Int63 functions in package math/rand to generate a non-negative pseudo-random number of type int64:
rand.Seed(time.Now().UnixNano()) n := rand.Int63() // for example 4601851300195147788  Similarly, rand.Float64 generates a pseudo-random float x, where 0&amp;nbsp;â¤&amp;nbsp;x&amp;nbsp;&amp;lt;&amp;nbsp;1:</description>
    </item>
    
    <item>
      <title>Generics (alternatives and workarounds)</title>
      <link>https://yourbasic.org/golang/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/generics/</guid>
      <description>Go has some built-in generic data types, such as slices and maps, and some generic functions, such as append and copy. However, there is no mechanism for writing your&amp;nbsp;own.
Here are some techniques that can be used in place of parametric polymorphism in&amp;nbsp;Go.
Find a well-fitting interface Describe the generic behaviour of your data with an interface.
The io.Reader interface, which represents the read end of a stream of data, is a good example:</description>
    </item>
    
    <item>
      <title>Get slices of keys and values from a map</title>
      <link>https://yourbasic.org/golang/slice-of-keys-values-from-map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/slice-of-keys-values-from-map/</guid>
      <description>You can use a range statement to extract slices of keys and values from a&amp;nbsp;map.
keys := make([]keyType, 0, len(myMap)) values := make([]valueType, 0, len(myMap)) for k, v := range myMap { keys = append(keys, k) values = append(values, v) } Further reading  Maps explained [code example]</description>
    </item>
    
    <item>
      <title>Get year, month, day from time</title>
      <link>https://yourbasic.org/golang/day-month-year-from-time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/day-month-year-from-time/</guid>
      <description>The Date function returns the year, month and day of a time.Time.
func (t Time) Date() (year int, month Month, day int) In use:
year, month, day := time.Now().Date() fmt.Println(year, month, day) // For example 2009 November 10 fmt.Println(year, int(month), day) // For example 2009 11 10 You can also extract the information with seperate calls:
t := time.Now() year := t.Year() // type int month := t.Month() // type time.</description>
    </item>
    
    <item>
      <title>Get your priorities right</title>
      <link>https://yourbasic.org/golang/gotcha-operator-precedence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-operator-precedence/</guid>
      <description>Why doesn&amp;rsquo;t this code compute the number of hours and seconds?
n := 43210 // time in seconds fmt.Println(n/60*60, &#34;hours and&#34;, n%60*60, &#34;seconds&#34;) 43200 hours and 600 seconds Answer The *, /, and % operators have the same precedence and are evaluated left to right: n/60*60 is the same as (n/60)*60.
Insert a pair of parantheses to force the correct evaluation order.
fmt.Println(n/(60*60), &#34;hours and&#34;, n%(60*60), &#34;seconds&#34;)  12 hours and 10 seconds  Or better yet, use a constant.</description>
    </item>
    
    <item>
      <title>Go and Pythagoras</title>
      <link>https://yourbasic.org/golang/gotcha-bitwise-operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-bitwise-operators/</guid>
      <description>Pythagorean triples are integer solutions to the Pythagorean Theorem, a2 + b2 = c2.
A well-known example is (3,&amp;nbsp;4,&amp;nbsp;5):
fmt.Println(3^2+4^2 == 5^2) // true The triple (6,&amp;nbsp;8,&amp;nbsp;10) is another example, but Go doesn&#39;t seem to agree.
fmt.Println(6^2+8^2 == 10^2) // false Answer The circumflex&amp;nbsp;^ denotes bitwise&amp;nbsp;XOR in&amp;nbsp;Go. The computation written in base&amp;nbsp;2 looks like&amp;nbsp;this:
 0011 ^ 0010 == 0001 (3^2 == 1) 0100 ^ 0010 == 0110 (4^2 == 6) 0101 ^ 0010 == 0111 (5^2 == 7)  Of course, 1 + 6 == 7; Go and Pythagoras agree on that.</description>
    </item>
    
    <item>
      <title>Go as a scripting language: lightweight, safe and fast</title>
      <link>https://yourbasic.org/golang/write-command-line-application/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/write-command-line-application/</guid>
      <description>This example is a simplified version of the Unix grep command. The program searches the input file for lines containing the given pattern and prints these lines.
func main() { log.SetPrefix(&#34;grep: &#34;) log.SetFlags(0) // no extra info in log messages if len(os.Args) != 3 { fmt.Printf(&#34;Usage: %v PATTERN FILE\n&#34;, os.Args[0]) return } pattern, err := regexp.Compile(os.Args[1]) if err != nil { log.Fatalln(err) } file, err := os.Open(os.Args[2]) if err !</description>
    </item>
    
    <item>
      <title>Go beginnerâs guide: top 4 resources to get you started</title>
      <link>https://yourbasic.org/golang/getting-started-hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/getting-started-hello-world/</guid>
      <description>Code in Go (try it out) The Go Playground is an interactive web&amp;nbsp;service that lets you run small Go programs, such as this &amp;ldquo;Hello,&amp;nbsp;world!&amp;rdquo; program, inside a sandbox. Try&amp;nbsp;it&amp;nbsp;out!
package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello, world!&#34;) } Learn Go basics A Tour of Go is an interactive tutorial with many example programs. It comes from the official golang site and teaches you the basics of Go programming directly in your browser.</description>
    </item>
    
    <item>
      <title>Go blueprints: code for common tasks</title>
      <link>https://yourbasic.org/golang/blueprint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/blueprint/</guid>
      <description>These code examples are intended to help you quickly solve some common everyday tasks in&amp;nbsp;Go. There are also a few oddities that may be nice to have when writing more exotic&amp;nbsp;code.</description>
    </item>
    
    <item>
      <title>Go operator precedence spells MACAO</title>
      <link>https://yourbasic.org/golang/operator-priority/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/operator-priority/</guid>
      <description>See Operators: complete list.</description>
    </item>
    
    <item>
      <title>Go step by step</title>
      <link>https://yourbasic.org/golang/nutshells/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/nutshells/</guid>
      <description> Detailed descriptions of core Go concepts
 Table of contents </description>
    </item>
    
    <item>
      <title>Go string handling overview [cheat sheet]</title>
      <link>https://yourbasic.org/golang/string-functions-reference-cheat-sheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/string-functions-reference-cheat-sheet/</guid>
      <description>String literals (escape characters) Concatenate Equal and compare (ignore case) Length in bytes or runes Index, substring, iterate Search (contains, prefix/suffix, index) Replace (uppercase/lowercase, trim) Split by space or comma Join strings with separator Format and convert Regular expressions  String literals (escape characters)   Expression Result Note     &#34;&#34;  Default zero value for type string   &#34;Japan æ¥æ¬&#34; Japan æ¥æ¬ Go code is Unicode text encoded in UTFâ8   &#34;</description>
    </item>
    
    <item>
      <title>Go tutorials</title>
      <link>https://yourbasic.org/golang/tutorials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/tutorials/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Go vs. Java: 15 main differences</title>
      <link>https://yourbasic.org/golang/go-vs-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/go-vs-java/</guid>
      <description>The following Java code, adapted from Effective Java, implements an immutable class representing a complex number.
public final class Complex { private final double re; private final double im; public Complex(double re, double im) { if (Double.isNaN(re) || Double.isNaN(im)) { throw new ArithmeticException(); } this.re = re; this.im = im; } public double realPart() { return re; } public double imaginaryPart() { return im; } public Complex add(Complex c) { return new Complex(re + c.</description>
    </item>
    
    <item>
      <title>Goroutines are lightweight threads</title>
      <link>https://yourbasic.org/golang/goroutines-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/goroutines-explained/</guid>
      <description>The go statement runs a func&amp;shy;tion in a sepa&amp;shy;rate thread of&amp;nbsp;execu&amp;shy;tion.
You can start a new thread of execution, a&amp;nbsp;goroutine, with the go statement. It&amp;nbsp;runs a function in a different, newly created, goroutine. All goroutines in a single program share the same address space.
go list.Sort() // Run list.Sort in parallel; donât wait for it. The following program will print &amp;ldquo;Hello from main goroutine&amp;rdquo;. It might also print &amp;ldquo;Hello from another goroutine&amp;rdquo;, depending on which of the two goroutines finish first.</description>
    </item>
    
    <item>
      <title>Hash checksums: MD5, SHA-1, SHA-256</title>
      <link>https://yourbasic.org/golang/hash-md5-sha256-string-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/hash-md5-sha256-string-file/</guid>
      <description>String checksum To compute the hash value of a string or byte slice, use the Sum function from a crypto package such as crypto/md5, crypto/sha1, or crypto/sha256.
s := &#34;Foo&#34; md5 := md5.Sum([]byte(s)) sha1 := sha1.Sum([]byte(s)) sha256 := sha256.Sum256([]byte(s)) fmt.Printf(&#34;%x\n&#34;, md5) fmt.Printf(&#34;%x\n&#34;, sha1) fmt.Printf(&#34;%x\n&#34;, sha256) 1356c67d7ad1638d816bfb822dd2c25d 201a6b3053cc1422d2c3670b62616221d2290929 1cbec737f863e4922cee63cc2ebbfaafcd1cff8b790d8cfd2e6a5d550b648afa File checksum To compute the hash value of a file or other input stream:
 create a new hash.Hash from a crypto package such as crypto/md5, crypto/sha1, or crypto/sha256, add data by writing to its io.</description>
    </item>
    
    <item>
      <title>Hello world HTTP server example</title>
      <link>https://yourbasic.org/golang/http-server-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/http-server-example/</guid>
      <description>A basic web server If you access the URL http://localhost:8080/world on a machine where the program below is running, you will be greeted by&amp;nbsp;this&amp;nbsp;page.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, HelloServer) http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) } func HelloServer(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello, %s!&amp;#34;, r.URL.Path[1:]) }  The call to http.HandleFunc tells the net.http package to handle all requests to the web root with the HelloServer function.</description>
    </item>
    
    <item>
      <title>How does characters add up?</title>
      <link>https://yourbasic.org/golang/gotcha-concatenate-rune-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-concatenate-rune-string/</guid>
      <description>Why doesn&amp;rsquo;t these print statements give the same result?
fmt.Println(&amp;#34;H&amp;#34; + &amp;#34;i&amp;#34;) fmt.Println(&amp;#39;H&amp;#39; + &amp;#39;i&amp;#39;)Hi 177 Answer The rune literals &#39;H&#39; and &#39;i&#39; are integer values identifying Unicode code points: &#39;H&#39; is 72 and &#39;i&#39; is&amp;nbsp;105.
You can turn a code point into a string with a&amp;nbsp;conversion.
fmt.Println(string(72) + string(&#39;i&#39;))// &#34;Hi&#34; You can also use the fmt.Sprintf function.
s := fmt.Sprintf(&#34;%c%c, world!&#34;, 72, &#39;i&#39;) fmt.Println(s)// &#34;Hi, world!&#34; This fmt cheat sheet lists the most common formatting verbs and flags.</description>
    </item>
    
    <item>
      <title>How to append anything (element, slice or string) to a slice</title>
      <link>https://yourbasic.org/golang/append-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/append-explained/</guid>
      <description>Append function basics Append one slice to another Append string to byte slice Performance  Append function basics With the built-in append function you can use a slice as a dynamic array. The&amp;nbsp;function appends any number of elements to the end of a&amp;nbsp;slice:
 if there is enough capacity, the underlying array is&amp;nbsp;reused; if not, a new underlying array is allocated and the data is copied&amp;nbsp;over.  Append returns the updated slice.</description>
    </item>
    
    <item>
      <title>How to best clear a slice: empty vs. nil</title>
      <link>https://yourbasic.org/golang/clear-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/clear-slice/</guid>
      <description>Remove all elements Keep allocated memory Empty slice vs. nil slice  Remove all elements To remove all elements, simply set the slice to nil.
a := []string{&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;} a = nil fmt.Println(a, len(a), cap(a)) // [] 0 0 This will release the underlying array to the garbage collector (assuming there are no other references).
Keep allocated memory To keep the underlying array, slice the slice to zero length.</description>
    </item>
    
    <item>
      <title>How to best implement an iterator</title>
      <link>https://yourbasic.org/golang/iterator-generator-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/iterator-generator-pattern/</guid>
      <description>Go has a built-in range loop for iterating over slices, arrays, strings, maps and channels. See 4 basic range loop (for-each) patterns.
To iterate over other types of data, an iterator function with callbacks is a clean and fairly efficient abstraction.
Basic iterator pattern // Iterate calls the f function with n = 1, 2, and 3. func Iterate(f func(n int)) { for i := 1; i  In use:</description>
    </item>
    
    <item>
      <title>How to debug deadlocks</title>
      <link>https://yourbasic.org/golang/detect-deadlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/detect-deadlock/</guid>
      <description>A deadlock happens when a group of goroutines are waiting for each other and none of them is able to&amp;nbsp;proceed.
 Take a look at this simple example.
func main() { ch := make(chan int) ch &amp;lt;- 1 fmt.Println(&amp;lt;-ch) } The program will get stuck on the channel send operation waiting forever for someone to read the value. Go is able to detect situations like this at runtime. Here is the output from our program:</description>
    </item>
    
    <item>
      <title>How to detect data races</title>
      <link>https://yourbasic.org/golang/detect-data-races/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/detect-data-races/</guid>
      <description>Data races can happen easily and are hard to debug. Luckily, the Go runtime is often able to&amp;nbsp;help.
Use -race to enable the built-in data race detector.
$ go test -race [packages] $ go run -race [packages] Example Here&amp;rsquo;s a program with a data race:
package main import &#34;fmt&#34; func main() { i := 0 go func() { i++ // write }() fmt.Println(i) // concurrent read } Running this program with the -race options tells us that there&amp;rsquo;s a race between the write at line&amp;nbsp;7 and the read at line&amp;nbsp;9:</description>
    </item>
    
    <item>
      <title>How to disable logging</title>
      <link>https://yourbasic.org/golang/disable-logging-output/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/disable-logging-output/</guid>
      <description>See Write log to file (or /dev/null).</description>
    </item>
    
    <item>
      <title>How to find the day of week</title>
      <link>https://yourbasic.org/golang/day-of-week-int/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/day-of-week-int/</guid>
      <description>  The Weekday function returns returns the day of the week of a time.Time.
func (t Time) Weekday() Weekday In use:
weekday := time.Now().Weekday() fmt.Println(weekday) // &#34;Tuesday&#34; fmt.Println(int(weekday)) // &#34;2&#34; Type Weekday The time.Weekday type specifies a day of the week (Sunday = 0, â¦).
type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday )</description>
    </item>
    
    <item>
      <title>How to get current timestamp</title>
      <link>https://yourbasic.org/golang/current-time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/current-time/</guid>
      <description> Use time.Now and one of time.Unix or time.UnixNano to get a timestamp.
now := time.Now() // current local time sec := now.Unix() // number of seconds since January 1, 1970 UTC nsec := now.UnixNano() // number of nanoseconds since January 1, 1970 UTC fmt.Println(now) // time.Time fmt.Println(sec) // int64 fmt.Println(nsec) // int64  2009-11-10 23:00:00 +0000 UTC m=+0.000000000 1257894000 1257894000000000000</description>
    </item>
    
    <item>
      <title>How to kill a goroutine</title>
      <link>https://yourbasic.org/golang/stop-goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/stop-goroutine/</guid>
      <description>One&amp;nbsp;goroutine can&#39;t forcibly stop another.
 To make a goroutine stoppable, let it listen for a stop signal on a dedicated quit&amp;nbsp;channel, and check this channel at suitable points in your goroutine.
quit := make(chan bool) go func() { for { select { case // â¦ } } }() // â¦ quit  Here is a more complete example, where we use a single channel for both data and signalling.</description>
    </item>
    
    <item>
      <title>How to reverse a string by byte or rune</title>
      <link>https://yourbasic.org/golang/reverse-utf8-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/reverse-utf8-string/</guid>
      <description>Byte by byte It&amp;rsquo;s pretty straightforward to reverse a string one byte at a time.
// Reverse returns a string with the bytes of s in reverse order. func Reverse(s string) string { var b strings.Builder b.Grow(len(s)) for i := len(s) - 1; i = 0; i-- { b.WriteByte(s[i]) } return b.String() }  Rune by rune To reverse a string by UTF-8 encoded characters is a bit trickier.</description>
    </item>
    
    <item>
      <title>How to use JSON with Go [best practices]</title>
      <link>https://yourbasic.org/golang/json-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/json-example/</guid>
      <description>The JSON data-interchange format is easy for humans to read and write, and efficient for machines to parse and generate.
 Default types Encode (marshal) struct to JSON Pretty print Decode (unmarshal) JSON to struct Arbitrary objects and arrays JSON file example  Default types The default Go types for decoding and encoding JSON are
 bool for JSON booleans, float64 for JSON numbers, string for JSON strings, and nil for JSON null.</description>
    </item>
    
    <item>
      <title>How to use the copy function</title>
      <link>https://yourbasic.org/golang/copy-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/copy-explained/</guid>
      <description>The built-in copy function copies elements into a destination slice dst from a source slice&amp;nbsp;src.
func copy(dst, src []Type) int It returns the number of elements copied, which will be the minimum of len(dst) and len(src). The result does not depend on whether the arguments overlap.
As a special case, it&amp;rsquo;s legal to copy bytes from a string to a slice of&amp;nbsp;bytes.
copy(dst []byte, src string) int Examples Copy from one slice to another var s = make([]int, 3) n := copy(s, []int{0, 1, 2, 3}) // n == 3, s == []int{0, 1, 2} Copy from a slice to itself s := []int{0, 1, 2} n := copy(s, s[1:]) // n == 2, s == []int{1, 2, 2} Copy from a string to a byte slice (special&amp;nbsp;case) var b = make([]byte, 5) copy(b, &#34;</description>
    </item>
    
    <item>
      <title>How to use the io.Reader interface</title>
      <link>https://yourbasic.org/golang/io-reader-interface-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/io-reader-interface-explained/</guid>
      <description>Basics Use a built-in reader Read directly from a byte stream Buffered reading and scanning  Basics The io.Reader interface represents an entity from which you can read a stream of&amp;nbsp;bytes.
type Reader interface { Read(buf []byte) (n int, err error) } Read reads up to len(buf) bytes into buf and returns the number of bytes read &amp;ndash; it returns an io.EOF error when the stream&amp;nbsp;ends.
The standard library provides numerous Reader implementations (including in-memory byte buffers, files and network connections), and Readers are accepted as input by many utilities (including the HTTP client and server implementations).</description>
    </item>
    
    <item>
      <title>How to use the io.Writer interface</title>
      <link>https://yourbasic.org/golang/io-writer-interface-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/io-writer-interface-explained/</guid>
      <description>Basics How to use a built-in writer (3&amp;nbsp;examples) Optimize string writes  Basics The io.Writer interface represents an entity to which you can write a stream of&amp;nbsp;bytes.
type Writer interface { Write(p []byte) (n int, err error) } Write writes up to len(p) bytes from p to the underlying data stream &amp;ndash; it returns the number of bytes written and any error encountered that caused the write to stop&amp;nbsp;early.</description>
    </item>
    
    <item>
      <title>Immutable strings</title>
      <link>https://yourbasic.org/golang/gotcha-strings-are-immutable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-strings-are-immutable/</guid>
      <description>Why doesn&amp;rsquo;t this code compile?
s := &#34;hello&#34; s[0] = &#39;H&#39; fmt.Println(s) ../main.go:3:7: cannot assign to s[0] Answer Go strings are immutable and behave like read-only byte slices (with a few extra properties).
To update the data, use a rune slice instead.
buf := []rune(&#34;hello&#34;) buf[0] = &#39;H&#39; s := string(buf) fmt.Println(s) // &#34;Hello&#34;  If the string only contains ASCII characters, you could also use a byte&amp;nbsp;slice.</description>
    </item>
    
    <item>
      <title>Index out of range</title>
      <link>https://yourbasic.org/golang/gotcha-index-out-of-range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-index-out-of-range/</guid>
      <description>Why does this program crash?
a := []int{1, 2, 3} for i := 1; i  panic: runtime error: index out of range goroutine 1 [running]: main.main() ../main.go:3 +0xe0 Answer In the last iteration, i equals len(a) which is outside the bounds of&amp;nbsp;a.
Arrays, slices and strings are indexed starting from zero so the values of a are found at a[0], a[1], a[2], â¦, a[len(a)-1].
Loop from 0 to len(a)-1 instead.</description>
    </item>
    
    <item>
      <title>Invalid memory address or nil pointer dereference</title>
      <link>https://yourbasic.org/golang/gotcha-nil-pointer-dereference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-nil-pointer-dereference/</guid>
      <description>Why does this program panic?
type Point struct { X, Y float64 } func (p *Point) Abs() float64 { return math.Sqrt(p.X*p.X + p.Y*p.Y) } func main() { var p *Point fmt.Println(p.Abs()) } panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xd2c5a] goroutine 1 [running]: main.(*Point).Abs(...) ../main.go:6 main.main() ../main.go:11 +0x1a Answer The uninitialized pointer p in the main function is nil, and you canât follow the nil pointer.</description>
    </item>
    
    <item>
      <title>Is &#34;three&#34; a digit?</title>
      <link>https://yourbasic.org/golang/gotcha-regexp-substring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-regexp-substring/</guid>
      <description>Why does the regular expression [0-9]*, which is supposed to match a string with zero or more digits, match a string with characters in&amp;nbsp;it?
matched, err := regexp.MatchString(`[0-9]*`, &#34;12three45&#34;) fmt.Println(matched) // true fmt.Println(err) // nil (regexp is valid)  Answer The function regexp.MatchString (as well as most functions in the regexp package) does substring matching.
To check if a full string matches [0-9]*, anchor the start and the end of the regular expression:</description>
    </item>
    
    <item>
      <title>Iteration variable doesnât see change in range loop</title>
      <link>https://yourbasic.org/golang/gotcha-range-copy-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-range-copy-array/</guid>
      <description>Why doesn&amp;rsquo;t the iteration variable x notice that a[1] has been updated?
var a [2]int for _, x := range a { fmt.Println(&#34;x =&#34;, x) a[1] = 8 } fmt.Println(&#34;a =&#34;, a) x = 0 x = 0 &amp;lt;- Why isn&#39;t this 8? a = [0 8] Answer The range expression a is evaluated once before beginning the loop and a copy of the array is used to generate the iteration values.</description>
    </item>
    
    <item>
      <title>Iteration variables and closures</title>
      <link>https://yourbasic.org/golang/gotcha-data-race-closure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-data-race-closure/</guid>
      <description>Why does this program
func main() { var wg sync.WaitGroup wg.Add(5) for i := 0; i  print
55555 (A WaitGroup waits for a collection of goroutines to finish.)
Answer There is a data race: the variable i is shared by six&amp;nbsp;(6) goroutines.
 A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write.
 To avoid this, use a local variable and pass the number as a parameter when starting the goroutine.</description>
    </item>
    
    <item>
      <title>Java to Go in-depth tutorial</title>
      <link>https://yourbasic.org/golang/go-java-tutorial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/go-java-tutorial/</guid>
      <description>This tutorial is in&amp;shy;tended to help Java deve&amp;shy;lopers come up to speed quickly with&amp;nbsp;Go.
 Hello stack (example) Main differences Syntax Constants Structs Pointers Slices   Making values Methods and interfaces Errors Panic and recover Goroutines and channels Hello server (example)    Hello stack (example) Let&amp;rsquo;s start with a small but complete example. It shows how to implement and use a simple abstract data type in Go.</description>
    </item>
    
    <item>
      <title>Last item in a slice/array</title>
      <link>https://yourbasic.org/golang/last-item-in-slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/last-item-in-slice/</guid>
      <description>Read last element Use the index len(a)-1 to access the last element of a slice or array&amp;nbsp;a.
a := []string{&#34;A&#34;, &#34;B&#34;, &#34;C&#34;} s := a[len(a)-1] // C  Go doesn&#39;t have negative indexing like Python does. This is a deliberate design decision â keeping the language simple can help save you from subtle bugs.  Remove last element a = a[:len(a)-1] // [A B] Watch out for memory leaks Warning: If the slice is permanent and the element temporary, you may want to remove the reference to the element before slicing it off.</description>
    </item>
    
    <item>
      <title>Learn to love your compiler</title>
      <link>https://yourbasic.org/golang/compiler-error-messages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/compiler-error-messages/</guid>
      <description>The Go compiler sometimes confuses and annoys developers who are new to the&amp;nbsp;language.
 This is a list of short articles with strategies and workarounds for common compiler error messages that tend to confuse fresh Go programmers.
 imported and not used Programs with unused imports won&#39;t compile.   declared and not used You must use all local variables.   multiple-value in single-value context When a function returns multiple values, you must use all of them.</description>
    </item>
    
    <item>
      <title>List all files (recursively) in a directory</title>
      <link>https://yourbasic.org/golang/list-files-in-directory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/list-files-in-directory/</guid>
      <description>Directory listing Use the ioutil.ReadDir function in package io/ioutil. It returns a sorted slice containing elements of type os.FileInfo.
The code in this example prints a sorted list of all file names in the current directory.
files, err := ioutil.ReadDir(&#34;.&#34;) if err != nil { log.Fatal(err) } for _, f := range files { fmt.Println(f.Name()) } Example output:
dev etc tmp usr Visit all files and folders in a directory tree Use the filepath.</description>
    </item>
    
    <item>
      <title>Make slices, maps and channels</title>
      <link>https://yourbasic.org/golang/make-slice-map-channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/make-slice-map-channel/</guid>
      <description>Slices, maps and channels can be created with the built-in make function. The memory is initialized with zero&amp;nbsp;values.
  Call Type Description     make(T, n) slice slice of type T with length&amp;nbsp;n   make(T, n, c)  capacity c   make(T) map map of type&amp;nbsp;T   make(T, n)  initial room for approximately n&amp;nbsp;elements   make(T) channel unbuffered channel of type&amp;nbsp;T   make(T, n)  buffered channel with buffer size&amp;nbsp;n    s := make([]int, 10, 100) // slice with len(s) == 10, cap(s) == 100 m := make(map[string]int, 100) // map with initial room for ~100 elements c := make(chan int, 10) // channel with a buffer size of 10 Slices, arrays and maps can also be created with composite literals.</description>
    </item>
    
    <item>
      <title>Maps explained: create, add, get, delete</title>
      <link>https://yourbasic.org/golang/maps-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/maps-explained/</guid>
      <description>Go maps are implemented by hash tables and have efficient add, get and delete operations.
 Create a new map Add, update, get and delete keys/values For-each range loop Performance and implementation  Create a new map var m map[string]int // nil map of string-int pairs m1 := make(map[string]float64) // Empty map of string-float64 pairs m2 := make(map[string]float64, 100) // Preallocate room for 100 entries m3 := map[string]float64{ // Map literal &#34;</description>
    </item>
    
    <item>
      <title>Maximum value of an int</title>
      <link>https://yourbasic.org/golang/max-min-int-uint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/max-min-int-uint/</guid>
      <description>Go has two predeclared integer types with implementation-specific sizes:
 a uint (unsigned integer) has either 32 or 64&amp;nbsp;bits, an int (signed integer) has the same size as a&amp;nbsp;uint.  This code computes the limit values as untyped constants.
const UintSize = 32  32 &amp; 1) // 32 or 64 const ( MaxInt = 1&amp;lt;&amp;lt;(UintSize-1) - 1 // 1MinInt = -MaxInt - 1 // -1 MaxUint = 1&amp;lt;&amp;lt;UintSize - 1 // 1)  The UintSize constant is also available in package math/bits.</description>
    </item>
    
    <item>
      <title>Measure execution time</title>
      <link>https://yourbasic.org/golang/measure-execution-time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/measure-execution-time/</guid>
      <description>Measure a piece of code start := time.Now() // Code to measure duration := time.Since(start) // Formatted string, such as &#34;2h3m0.5s&#34; or &#34;4.503Î¼s&#34; fmt.Println(duration) // Nanoseconds as int64 fmt.Println(duration.Nanoseconds()) Measure a function call You can track the execution time of a complete function call with this one-liner, which logs the result to the standard error stream.
func foo() { defer duration(track(&#34;foo&#34;)) // Code to measure } func track(msg string) (string, time.</description>
    </item>
    
    <item>
      <title>Methods explained</title>
      <link>https://yourbasic.org/golang/methods-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/methods-explained/</guid>
      <description>Go doesn&#39;t have classes, but you can define methods on types.
 You can define methods on any type declared in a type definition.
 A method is a function with an extra receiver&amp;nbsp;argument. The receiver sits between the func keyword and the method&amp;nbsp;name.  In this example, the HasGarage method is associated with the&amp;nbsp;House type. The&amp;nbsp;method receiver is called&amp;nbsp;p.
type House struct { garage bool } func (p *House) HasGarage() bool { return p.</description>
    </item>
    
    <item>
      <title>Missing function body</title>
      <link>https://yourbasic.org/golang/opening-brace-separate-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/opening-brace-separate-line/</guid>
      <description>As you may have noticed, programs with an opening brace on separate line do not compile.
func main() { fmt.Println(&amp;#34;Hello&amp;#34;) }../main.go:1:6: missing function body for &amp;#34;main&amp;#34; ../main.go:2:1: syntax error: unexpected semicolon or newline before { You must write:
func main() { fmt.Println(&amp;#34;Hello&amp;#34;) } This is a trade-off in the design of the Go language.
 Some have argued that the lexer should do lookahead to permit the brace to live on the next line.</description>
    </item>
    
    <item>
      <title>Multiple-value in single-value context</title>
      <link>https://yourbasic.org/golang/gotcha-multiple-value-single-value-context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-multiple-value-single-value-context/</guid>
      <description>Why does this code give a compile error?
t := time.Parse(time.RFC3339, &#34;2018-04-06T10:49:05Z&#34;) fmt.Println(t) ../main.go:9:17: multiple-value time.Parse() in single-value context Answer The time.Parse function returns two values, a time.Time and an error, and you must use&amp;nbsp;both.
t, err := time.Parse(time.RFC3339, &#34;2018-04-06T10:49:05Z&#34;) if err != nil { // TODO: Handle error. } fmt.Println(t) 2018-04-06 10:49:05 +0000 UTC Blank identifier (underscore) You can use the blank identifier to ignore unwanted return values.</description>
    </item>
    
    <item>
      <title>Mutual exclusion lock (mutex)</title>
      <link>https://yourbasic.org/golang/mutex-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/mutex-explained/</guid>
      <description>Mutexes let you synchronize data access by explicit locking, without channels.
 Sometimes itâs more convenient to synchronize data access by explicit locking instead of using channels. The Go standard library offers a mutual exclusion lock, sync.Mutex, for this purpose.
Use with caution For this type of locking to be safe, it&amp;rsquo;s crucial that all accesses to the shared data, both reads and writes, are performed only when a goroutine holds the lock.</description>
    </item>
    
    <item>
      <title>Named return values [best practice]</title>
      <link>https://yourbasic.org/golang/named-return-values-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/named-return-values-parameters/</guid>
      <description>In Go return parameters may be named and used as regular variables. When the function returns, they are used as return&amp;nbsp;values.
func f() (i int, s string) { i = 17 s = &#34;abc&#34; return // same as return i, s } Named return parameters are initialized to their zero&amp;nbsp;values.
The names are not mandatory but can make for good documentation. Correctly used, named return parameters can also help clarify and clean up the&amp;nbsp;code.</description>
    </item>
    
    <item>
      <title>Nil is not nil</title>
      <link>https://yourbasic.org/golang/gotcha-why-nil-error-not-equal-nil/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-why-nil-error-not-equal-nil/</guid>
      <description>Why is nil not equal to nil in this example?
func Foo() error { var err *os.PathError = nil // â¦ return err } func main() { err := Foo() fmt.Println(err) // &amp;lt;nil&amp;gt; fmt.Println(err == nil) // false } Answer An interface value is equal to nil only if both its value and dynamic type are nil. In the example above, Foo() returns [nil, *os.PathError] and we compare it with [nil,&amp;nbsp;nil].</description>
    </item>
    
    <item>
      <title>No end in sight</title>
      <link>https://yourbasic.org/golang/gotcha-integer-overflow-wrap-around/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-integer-overflow-wrap-around/</guid>
      <description>Why does this loop run forever?
var b byte for b = 250; b  Answer After the b == 255 iteration, b++ is executed. This overflows (since the maximum value for a byte is 255) and results in b == 0. Therefore b &amp;lt;= 255 still holds and the loop restarts from&amp;nbsp;0.
  For unsigned integer values, the operations +, -, *, and &amp;lt;&amp;lt; are computed modulo 2n, where n is the bit width of the unsigned integer type.</description>
    </item>
    
    <item>
      <title>No JSON in sight</title>
      <link>https://yourbasic.org/golang/gotcha-json-marshal-empty/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-json-marshal-empty/</guid>
      <description>Why does json.Marshal produce empty structs in the JSON text output?
type Person struct { name string age int } p := Person{&#34;Alice&#34;, 22} jsonData, _ := json.Marshal(p) fmt.Println(string(jsonData)) {} Answer Only exported fields of a Go struct will be present in the JSON output.
type Person struct { Name string // Changed to capital N Age int // Changed to capital A } p := Person{&#34;Alice&#34;, 22} jsonData, _ := json.</description>
    </item>
    
    <item>
      <title>Non-declaration statement outside function body</title>
      <link>https://yourbasic.org/golang/short-variable-declaration-outside-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/short-variable-declaration-outside-function/</guid>
      <description>As you may have noticed, a program with short variable declarations outside a function doesn&amp;rsquo;t&amp;nbsp;compile.
package main n := 1 // illegal func main() {} ../main.go:3:1: syntax error: non-declaration statement outside function body Short variable declarations can only be used inside functions. You have to write
package main var n = 1 func main() {} This is a trade-off in the design of the Go language.
 At the top level, every declaration begins with a keyword.</description>
    </item>
    
    <item>
      <title>Numbers that start with zero</title>
      <link>https://yourbasic.org/golang/gotcha-octal-decimal-hexadecimal-literal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-octal-decimal-hexadecimal-literal/</guid>
      <description>What&amp;rsquo;s up with the counting in this example?
const ( Century = 100 Decade = 010 Year = 001 ) // The world&#39;s oldest person, Emma Morano, lived for a century, // two decades and two years. fmt.Println(&#34;She was&#34;, Century+2*Decade+2*Year, &#34;years old.&#34;) She was 118 years old. Answer 010 is a number in base&amp;nbsp;8, therefore it means&amp;nbsp;8, not&amp;nbsp;10.
Integer literals in Go are specified in octal, decimal or hexadecimal.</description>
    </item>
    
    <item>
      <title>Object-oriented programming without inheritance</title>
      <link>https://yourbasic.org/golang/inheritance-object-oriented/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/inheritance-object-oriented/</guid>
      <description>Go doesnât have inheritance &amp;ndash; instead composition, embed&amp;shy;ding and inter&amp;shy;faces support code reuse and poly&amp;shy;morphism.
 Object-oriented programming with inheritance Code reuse by composition Code reuse by embedding Polymorphism and dynamic dispatch with interfaces  Object-oriented programming with inheritance Inheritance in traditional object-oriented languages offers three features in&amp;nbsp;one. When a&amp;nbsp;Dog inherits from an&amp;nbsp;Animal
 the Dog class reuses code from the Animal&amp;nbsp;class, a variable x of type Animal can refer to either a Dog or an Animal, x.</description>
    </item>
    
    <item>
      <title>Operators: complete list</title>
      <link>https://yourbasic.org/golang/operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/operators/</guid>
      <description>Arithmetic Comparison Logical Pointers and channels Operator precedence  Arithmetic   Operator Name Types     + sum integers, floats, complex values, strings   - difference integers, floats, complex values   * product    / quotient    % remainder integers   &amp; bitwise AND    | bitwise OR    ^ bitwise XOR    &amp;^ bit clear (AND&amp;nbsp;NOT)     left shift integer    right shift integer  unsigned integer    See Arithmetic operators in the Go language specification for complete definitions of the shift, quotient and remainder operators, integer overflow, and floating point behavior.</description>
    </item>
    
    <item>
      <title>Optional parameters, default parameter values and method overloading</title>
      <link>https://yourbasic.org/golang/overload-overwrite-optional-parameter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/overload-overwrite-optional-parameter/</guid>
      <description>By design, Go does not support
 optional parameters, default parameter values, or method overloading.   Method dispatch is simplified if it doesn&amp;rsquo;t need to do type matching as well. Experience with other languages told us that having a variety of methods with the same name but different signatures was occasionally useful but that it could also be confusing and fragile in practice. Matching only by name and requiring consistency in the types was a major simplifying decision in Go&amp;rsquo;s type system.</description>
    </item>
    
    <item>
      <title>Package documentation</title>
      <link>https://yourbasic.org/golang/package-documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/package-documentation/</guid>
      <description>godoc.org website Local godoc server go doc command-line tool Create documentation Runnable documentation examples  godoc.org website The GoDoc website hosts docu&amp;shy;men&amp;shy;tation for all public Go packages on Bitbucket, GitHub, Google Project Hosting and&amp;nbsp;Launchpad.
Local godoc server The godoc command extracts and generates documentation for all locally installed Go programs, both your own code and the standard libraries.
The following command starts a web server that presents the documentation at http://localhost:6060/.</description>
    </item>
    
    <item>
      <title>Package initialization and program execution order</title>
      <link>https://yourbasic.org/golang/package-init-function-main-execution-order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/package-init-function-main-execution-order/</guid>
      <description>Basics Program execution Package initialization Init function Warning  Basics  First the main package is initialized.  Imported packages are initialized before the package itself. Packages are initialized one at a time: first package-level variables are initialized in declaration order, then the init functions are run.  Finally the main function is called.  Program execution Program execution begins by initializing the main package and then calling the function main.</description>
    </item>
    
    <item>
      <title>Packages explained: declare, import, download, document</title>
      <link>https://yourbasic.org/golang/packages-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/packages-explained/</guid>
      <description>Basics Declare a package Package name conflicts Dot imports Package download Package documentation  Basics Every Go program is made up of packages and each package has an&amp;nbsp;import&amp;nbsp;path:
 &amp;quot;fmt&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;github.com/yourbasic/graph&amp;quot;  Packages in the standard library have short import paths, such&amp;nbsp;as &amp;quot;fmt&amp;quot; and &amp;quot;math/rand&amp;quot;. Third-party packages, such as &amp;quot;github.com/yourbasic/graph&amp;quot;, typically have an import path that includes a hosting service (github.com) and an organization name (yourbasic).
By convention, the package name is the same as the last element of the import path:</description>
    </item>
    
    <item>
      <title>Panics, stack traces and how to recover [best practice]</title>
      <link>https://yourbasic.org/golang/recover-from-panic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/recover-from-panic/</guid>
      <description>A panic is an exception in Go Stack traces Interpret a stack trace Print and log a stack trace Level of detail   Recover and catch a panic Panic handler example Return a value   Test a panic (utility function)  A panic is an exception in Go Panics are similar to C++ and Java exceptions, but are only intended for run-time errors, such as following a nil pointer or attempting to index an array out of bounds.</description>
    </item>
    
    <item>
      <title>Pass a slice to a variadic function</title>
      <link>https://yourbasic.org/golang/pass-slice-to-variadic-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/pass-slice-to-variadic-function/</guid>
      <description>See Variadic functions (&amp;hellip;T).</description>
    </item>
    
    <item>
      <title>Pick the right one: int vs. int64</title>
      <link>https://yourbasic.org/golang/int-vs-int64/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/int-vs-int64/</guid>
      <description>Use int for indexing An index, length or capacity should normally be an int. The int type is either 32 or 64&amp;nbsp;bits, and always big enough to hold the maximum possible length of an&amp;nbsp;array.
See Maximum value of an int for code to compute the maximum value of an&amp;nbsp;int.
Use int64 and friends for data The types int8, int16, int32, and int64 (and their unsigned counterparts) are best suited for data.</description>
    </item>
    
    <item>
      <title>Pointer vs. value receiver</title>
      <link>https://yourbasic.org/golang/pointer-vs-value-receiver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/pointer-vs-value-receiver/</guid>
      <description>Basic guidelines  For a given type, don&amp;rsquo;t mix value and pointer receivers. If in doubt, use pointer receivers (they are safe and extendable).  Pointer receivers You must use pointer receivers
 if any method needs to mutate the receiver, for structs that contain a sync.Mutex or similar synchronizing field (they musn&amp;rsquo;t be copied).  You probably want to use pointer receivers
 for large structs or arrays (it can be more efficient), in all other cases.</description>
    </item>
    
    <item>
      <title>Pointers explained</title>
      <link>https://yourbasic.org/golang/pointers-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/pointers-explained/</guid>
      <description>A pointer is a vari&amp;shy;able that con&amp;shy;tains the address of an&amp;nbsp;object.
Basics Address operator Pointer indirection Pointers as parameters  Basics Structs and arrays are copied when used in assignments and passed as arguments to functions. With pointers this can be&amp;nbsp;avoided.
Pointers store addresses of objects. The addresses can be passed around more efficiently than the actual&amp;nbsp;objects.
A pointer has type *T. The keyword new allocates a new object and returns its&amp;nbsp;address.</description>
    </item>
    
    <item>
      <title>Public vs. private</title>
      <link>https://yourbasic.org/golang/public-private/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/public-private/</guid>
      <description>A package is the smallest unit of private encap&amp;shy;sulation in&amp;nbsp;Go.
 All identifiers defined within a package are visible throughout that package. When importing a package you can access only its exported identifiers. An identifier is exported if it begins with a capital letter.  Exported and unexported identifiers are used to describe the public interface of a package and to guard against certain programming errors.
Warning: Unexported identifiers is not a security measure and it does not hide or protect any information.</description>
    </item>
    
    <item>
      <title>Quicksort optimizations explained [complete code]</title>
      <link>https://yourbasic.org/golang/quicksort-optimizations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/quicksort-optimizations/</guid>
      <description>Most Quicksort optimi&amp;shy;zations give only small improve&amp;shy;ments. Here&amp;nbsp;are three that can make a&amp;nbsp;real differ&amp;shy;ence.
Algorithm overview Pivot element 3-way partition Combining algorithms  Algorithm overview  Pick an element p, called a pivot, from the list. Partition the list so that  all elements less than p come first, all elements greater than p come last, elements equal to p go into the middle.  Recursively apply the above steps to the sublists of small and large elements.</description>
    </item>
    
    <item>
      <title>Read a file (stdin) line by line</title>
      <link>https://yourbasic.org/golang/read-file-line-by-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/read-file-line-by-line/</guid>
      <description>Read from file Read from stdin Read from any stream  Read from file Use a bufio.Scanner to read a file line by&amp;nbsp;line.
file, err := os.Open(&#34;file.txt&#34;) if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } if err := scanner.Err(); err != nil { log.Fatal(err) }  Read from stdin Use os.Stdin to read from the standard input&amp;nbsp;stream.
scanner := bufio.</description>
    </item>
    
    <item>
      <title>Redeclaring variables</title>
      <link>https://yourbasic.org/golang/redeclaring-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/redeclaring-variables/</guid>
      <description>You can&amp;rsquo;t redeclare a variable which has already been declared in the same block.
func main() { m := 0 m := 1 fmt.Println(m) }../main.go:3:4: no new variables on left side of := However, variables can be redeclared in short multi-variable declarations where at least one new variable is introduced.
func main() { m := 0 m, n := 1, 2 fmt.Println(m, n) }  Unlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new.</description>
    </item>
    
    <item>
      <title>Regexp tutorial and cheat sheet</title>
      <link>https://yourbasic.org/golang/regexp-cheat-sheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/regexp-cheat-sheet/</guid>
      <description>A regular expression is a sequence of characters that define a&amp;nbsp;search pattern.
 Basics Compile Raw strings   Cheat sheet Choice and grouping Repetition (greedy and non-greedy) Character classes Special characters Text boundary anchors Case-insensitive and multiline matches     Code examples First match Location All matches Replace Split   Implementation     Basics The regular expression a.b matches any string that starts with an&amp;nbsp;a, ends with a&amp;nbsp;b, and has a single character in between (the period matches any character).</description>
    </item>
    
    <item>
      <title>Remove all duplicate whitespace</title>
      <link>https://yourbasic.org/golang/remove-duplicate-whitespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/remove-duplicate-whitespace/</guid>
      <description>space := regexp.MustCompile(`\s+`) s := space.ReplaceAllString(&#34;Hello \t \n world!&#34;, &#34; &#34;) fmt.Printf(&#34;%q&#34;, s) // &#34;Hello world!&#34; \s+ is a regular expression:
 the character class \s matches a space, tab, new line, carriage return or form feed, and + says âone or more of thoseâ.  In other words, the code will replace each whitespace substring with a single space&amp;nbsp;character.
Trim leading and trailing space  To trim leading and trailing whitespace, use the strings.</description>
    </item>
    
    <item>
      <title>Round float to 2 decimal places</title>
      <link>https://yourbasic.org/golang/round-float-2-decimal-places/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/round-float-2-decimal-places/</guid>
      <description>Float to string To display the value as a string, use the fmt.Sprintf method.
s := fmt.Sprintf(&#34;%.2f&#34;, 12.3456) // s == &#34;12.35&#34;  The fmt cheat sheet lists the most common formatting verbs and flags.
Float to float To round to a floating-point value, use one of these techniques.
x := 12.3456 fmt.Println(math.Floor(x*100)/100) // 12.34 (round down) fmt.Println(math.Round(x*100)/100) // 12.35 (round to nearest) fmt.Println(math.Ceil(x*100)/100) // 12.35 (round up)  Due to the quirks of floating point representation, these rounded values may be slightly&amp;nbsp;off.</description>
    </item>
    
    <item>
      <title>Round float to integer value</title>
      <link>https://yourbasic.org/golang/round-float-to-int/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/round-float-to-int/</guid>
      <description>Round away from zero Round to even number Convert to an int type Before Go 1.10  Round away from zeroGo&amp;nbsp;1.10 Use math.Round to return the nearest integer, as a float64, rounding ties away from&amp;nbsp;zero.
fmt.Println(math.Round(-0.6)) // -1 fmt.Println(math.Round(-0.4)) // -0 fmt.Println(math.Round(0.4)) // 0 fmt.Println(math.Round(0.6)) // 1  Note the special cases.
Round(Â±0) = Â±0 Round(Â±Inf) = Â±Inf Round(NaN) = NaN Round to even numberGo&amp;nbsp;1.10 Use math.RoundToEven to return the nearest integer, as a float64, rounding ties to an even&amp;nbsp;number.</description>
    </item>
    
    <item>
      <title>Runes and character encoding</title>
      <link>https://yourbasic.org/golang/rune/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/rune/</guid>
      <description>Runic letters encoded in stone, Ballstorp 1900 Characters, ASCII and Unicode  The rune type is an alias for int32, and is used to emphasize than an integer represents a code&amp;nbsp;point.
 ASCII defines 128 characters, identified by the code points 0â127. It covers English letters, Latin numbers, and a few other characters.
Unicode, which is a superset of ASCII, defines a codespace of 1,114,112 code points. Unicode version 10.</description>
    </item>
    
    <item>
      <title>Select waits on a group of channels</title>
      <link>https://yourbasic.org/golang/select-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/select-explained/</guid>
      <description>The select statement waits for multiple send or receive opera&amp;shy;tions simul&amp;shy;taneously.
 The statement blocks as a whole until one of the operations becomes unblocked. If several cases can proceed, a single one of them will be chosen at random.  // blocks until there&#39;s data available on ch1 or ch2 select { case  Send and receive operations on a nil channel block forever. This can be used to disable a channel in a select statement:</description>
    </item>
    
    <item>
      <title>Shadowed variables</title>
      <link>https://yourbasic.org/golang/gotcha-shadowing-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-shadowing-variables/</guid>
      <description>Why doesn&amp;rsquo;t n change?
func main() { n := 0 if true { n := 1 n++ } fmt.Println(n) // 0 } Answer The statement n := 1 declares a new variable which shadows the original n throughout the scope of the if&amp;nbsp;statement.
To reuse n from the outer block, write n = 1 instead.
func main() { n := 0 if true { n = 1 n++ } fmt.</description>
    </item>
    
    <item>
      <title>Shuffle a slice or array</title>
      <link>https://yourbasic.org/golang/shuffle-slice-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/shuffle-slice-array/</guid>
      <description>The rand.Shuffle function in package math/rand shuffles an input sequence using a given swap function.
a := []int{1, 2, 3, 4, 5, 6, 7, 8} rand.Seed(time.Now().UnixNano()) rand.Shuffle(len(a), func(i, j int) { a[i], a[j] = a[j], a[i] })[5 8 6 4 3 7 2 1] Warning: Without the call to rand.Seed you will get the same sequence of pseudo&amp;shy;random numbers each time you run the program.  Further reading  Generate random numbers, characters and slice elements</description>
    </item>
    
    <item>
      <title>Slices/arrays explained: create, index, slice, iterate</title>
      <link>https://yourbasic.org/golang/slices-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/slices-explained/</guid>
      <description>Basics Construction Slicing   Iteration Append and copy Stacks and queues    Basics A slice doesn&amp;rsquo;t store any data, it just describes a section of an underlying&amp;nbsp;array.
 When you change an element of a slice, you modify the corresponding element of its underlying array, and other slices that share the same underlying array will see the change. A slice can grow and shrink within the bounds of the underlying array.</description>
    </item>
    
    <item>
      <title>Sort a map by key or value</title>
      <link>https://yourbasic.org/golang/sort-map-keys-values/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/sort-map-keys-values/</guid>
      <description>A map is an unordered collection of key-value pairs. If you need a stable iteration order, you must maintain a separate data structure.  This example uses a sorted slice of keys to print a map[string]int in key order.
m := map[string]int{&amp;#34;Alice&amp;#34;: 23, &amp;#34;Eve&amp;#34;: 2, &amp;#34;Bob&amp;#34;: 25} keys := make([]string, 0, len(m)) for k := range m { keys = append(keys, k) } sort.Strings(keys) for _, k := range keys { fmt.</description>
    </item>
    
    <item>
      <title>Stack traces in detail</title>
      <link>https://yourbasic.org/golang/stack-trace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/stack-trace/</guid>
      <description>See Recover from a panic [best practices].</description>
    </item>
    
    <item>
      <title>Start a new Go project [standard layout]</title>
      <link>https://yourbasic.org/golang/library-package-example-template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/library-package-example-template/</guid>
      <description>The repository at github.com/yourbasic/fenwick is a small but complete Go library package. It shows the structure of a basic project and can be used as a template.
In addition to source code and resources, it includes
 a README file with sections on  installation, documentation and compatibility policy,  unit tests, benchmarks, godoc links, a testable doc example and a licence.  Further reading 
Your basic API is an introduction to API design with examples in Go and&amp;nbsp;Java.</description>
    </item>
    
    <item>
      <title>Table-driven unit tests</title>
      <link>https://yourbasic.org/golang/table-driven-unit-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/table-driven-unit-test/</guid>
      <description>Here is the code we want to&amp;nbsp;test.
package search // Find returns the smallest index i at which x   Put the test code in a file whose name ends with _test.go. Write a function TestXXX with a single argument of type *testing.T. The test framework runs each such function. To indicate a failed test, call a failure function such as t.Errorf.  package search import &#34;testing&#34; var tests = []struct { a []int x int exp int }{ {[]int{}, 1, 0}, {[]int{1, 2, 3, 3}, 0, 0}, {[]int{1, 2, 3, 3}, 1, 0}, {[]int{1, 2, 3, 3}, 2, 1}, {[]int{1, 2, 3, 3}, 3, 3}, // incorrect test case {[]int{1, 2, 3, 3}, 4, 4}, } func TestFind(t *testing.</description>
    </item>
    
    <item>
      <title>The 3 ways to sort in Go</title>
      <link>https://yourbasic.org/golang/how-to-sort-in-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/how-to-sort-in-go/</guid>
      <description>Slice of ints, float64s or strings Custom comparator Custom data structures Bonus: Sort a map by key or value Performance and implementation  Sort a slice of ints, float64s or strings Use one of the functions
 sort.Ints sort.Float64s sort.Strings  s := []int{4, 2, 3, 1} sort.Ints(s) fmt.Println(s) // [1 2 3 4]  Package radix contains a drop-in replacement for sort.Strings, which can be more than twice as fast in some settings.</description>
    </item>
    
    <item>
      <title>The empty interface</title>
      <link>https://yourbasic.org/golang/empty-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/empty-interface/</guid>
      <description>See Interfaces in a nutshell.</description>
    </item>
    
    <item>
      <title>Time is not a number</title>
      <link>https://yourbasic.org/golang/gotcha-multiply-duration-integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-multiply-duration-integer/</guid>
      <description>Why doesn&amp;rsquo;t this compile?
n := 100 time.Sleep(n * time.Millisecond) invalid operation: n * time.Millisecond (mismatched types int and time.Duration) Answer There is no mixing of numeric types in Go. You can only multiply a time.Duration with
 another time.Duration, or an untyped integer constant.  Here are three correct examples.
var n time.Duration = 100 time.Sleep(n * time.Millisecond)  const n = 100 time.Sleep(n * time.Millisecond)  time.</description>
    </item>
    
    <item>
      <title>Time zones</title>
      <link>https://yourbasic.org/golang/time-change-convert-location-timezone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/time-change-convert-location-timezone/</guid>
      <description>Each Time has an associated Location, which is used for display purposes.
The method In returns a time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time.
Here is a convenience function that changes the location associated with a&amp;nbsp;time.
// TimeIn returns the time in UTC if the name is &#34;&#34; or &#34;UTC&#34;. // It returns the local time if the name is &#34;</description>
    </item>
    
    <item>
      <title>Timer and Ticker: events in the future</title>
      <link>https://yourbasic.org/golang/time-reset-wait-stop-timeout-cancel-interval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/time-reset-wait-stop-timeout-cancel-interval/</guid>
      <description>Timers and Tickers let you execute code in the future, once or repeatedly.
 Timeout (Timer) Repeat (Ticker) Wait, act and cancel  Timeout (Timer) time.After waits for a specified duration and then sends the current time on the returned channel:
select { case news := &amp;lt;-AFP: fmt.Println(news) case &amp;lt;-time.After(time.Hour): fmt.Println(&amp;#34;No news in an hour.&amp;#34;) } The underlying time.Timer will not be recovered by the garbage collector until the timer fires.</description>
    </item>
    
    <item>
      <title>Type alias explained</title>
      <link>https://yourbasic.org/golang/type-alias/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/type-alias/</guid>
      <description>An alias declaration has the form
type T1 = T2 as opposed to a standard type definition
type T1 T2 An alias declaration doesn&amp;rsquo;t create a new distinct type different from the type it&amp;rsquo;s created from. It just introduces an alias name T1, an alternate spelling, for the type denoted by&amp;nbsp;T2.
Type aliases are not meant for everyday use. They were introduced to support gradual code repair while moving a type between packages during large-scale refactoring.</description>
    </item>
    
    <item>
      <title>Type assertions and type switches</title>
      <link>https://yourbasic.org/golang/type-assertion-switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/type-assertion-switch/</guid>
      <description>A type assertion provides access to an interfaceâs concrete value.
 Type assertions Type switches  Type assertions A type assertion doesnât really convert an interface to another data type, but it provides access to an interfaceâs concrete value, which is typically what you&amp;nbsp;want.
The type assertion x.(T) asserts that the concrete value stored in&amp;nbsp;x is of type&amp;nbsp;T, and that x is&amp;nbsp;not&amp;nbsp;nil.
 If T is not an interface, it asserts that the dynamic type of&amp;nbsp;x is identical to&amp;nbsp;T.</description>
    </item>
    
    <item>
      <title>Type, value and equality of interfaces</title>
      <link>https://yourbasic.org/golang/interfaces-explained/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/interfaces-explained/</guid>
      <description>Interface type Structural typing The empty interface Interface values Equality  Interface type  An interface type consists of a set of method signatures. A variable of interface type can hold any value that implements these methods.
 In this example both Temp and *Point implement the MyStringer interface.
type MyStringer interface { String() string }type Temp int func (t Temp) String() string { return strconv.Itoa(int(t)) + &amp;#34; Â°C&amp;#34; } type Point struct { x, y int } func (p *Point) String() string { return fmt.</description>
    </item>
    
    <item>
      <title>Unexpected &#43;&#43;, expecting expression</title>
      <link>https://yourbasic.org/golang/gotcha-increment-decrement-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-increment-decrement-statement/</guid>
      <description>Why doesn&amp;rsquo;t these lines compile?
i := 0 fmt.Println(++i) fmt.Println(i++) main.go:9:14: syntax error: unexpected ++, expecting expression main.go:10:15: syntax error: unexpected ++, expecting comma or ) Answer In Go increment and decrement operations canât be used as expressions, only as statements. Also, only the postfix notation is&amp;nbsp;allowed.
The above snippet needs to be written as:
i := 0 i++ fmt.Println(i) fmt.Println(i) i++  Without pointer arithmetic, the convenience value of pre- and postfix increment operators drops.</description>
    </item>
    
    <item>
      <title>Unexpected newline</title>
      <link>https://yourbasic.org/golang/gotcha-missing-comma-slice-array-map-literal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-missing-comma-slice-array-map-literal/</guid>
      <description>Why doesn&amp;rsquo;t this program compile?
func main() { fruit := []string{ &#34;apple&#34;, &#34;banana&#34;, &#34;cherry&#34; } fmt.Println(fruit) } ../main.go:5:11: syntax error: unexpected newline, expecting comma or } Answer In a multi-line slice, array or map literal, every line must end with a comma.
func main() { fruit := []string{ &#34;apple&#34;, &#34;banana&#34;, &#34;cherry&#34;, // comma added } fmt.Println(fruit) // &#34;[apple banana cherry]&#34; } This behavior is a consequence of the Go semicolon insertion rules.</description>
    </item>
    
    <item>
      <title>Unexpected values in range loop</title>
      <link>https://yourbasic.org/golang/gotcha-unexpected-values-range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-unexpected-values-range/</guid>
      <description>Why does this code
primes := []int{2, 3, 5, 7} for p := range primes { fmt.Println(p) } print
0 1 2 3 Answer For arrays and slices, the range loop generates two&amp;nbsp;values:
  first the index,  then the data at this position.  If you omit the second value, you get only the indices.
To print the data, use the second value instead:
primes := []int{2, 3, 5, 7} for _, p := range primes { fmt.</description>
    </item>
    
    <item>
      <title>Untyped numeric constants with no limits</title>
      <link>https://yourbasic.org/golang/untyped-constants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/untyped-constants/</guid>
      <description>Constants may be typed or untyped.
const a uint = 17 const b = 55 An untyped constant has no limits. When it&amp;rsquo;s used in a context that requires a type, a type will be inferred and a limit applied.
const big = 10000000000 // Ok, even though it&#39;s too big for an int. const bigger = big * 100 // Still ok. var i int = big / 100 // No problem: the new result fits in an int.</description>
    </item>
    
    <item>
      <title>Unused local variables</title>
      <link>https://yourbasic.org/golang/unused-local-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/unused-local-variables/</guid>
      <description>As you may have noticed, programs with unused local variables do not compile. func main() { var n int // &amp;ldquo;n declared and not used&amp;rdquo; n = 5 // this doesn&amp;rsquo;t help }
../main.go:2:6: n declared and not used This is a deliberate feature of the Go language.
 The presence of an unused variable may indicate a bug [&amp;hellip;] Go refuses to compile programs with unused variables or imports, trading short-term convenience for long-term build speed and program clarity.</description>
    </item>
    
    <item>
      <title>Unused package imports</title>
      <link>https://yourbasic.org/golang/unused-imports/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/unused-imports/</guid>
      <description>As you may have noticed, programs with unused package imports do not compile.
package main import ( &#34;fmt&#34; &#34;log&#34; // &#34;imported and not used: log&#34; ) func main() { fmt.Println(&#34;Hello&#34;) } ../main.go:5:2: imported and not used: &amp;#34;log&amp;#34; This is a deliberate feature of the Go language.
 The presence of an unused variable may indicate a bug [&amp;hellip;] Go refuses to compile programs with unused variables or imports, trading short-term convenience for long-term build speed and program clarity.</description>
    </item>
    
    <item>
      <title>User-friendly access to crypto/rand</title>
      <link>https://yourbasic.org/golang/crypto-rand-int/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/crypto-rand-int/</guid>
      <description>Go has two packages for random numbers:
 math/rand implements a large selection of pseudo-random number generators. crypto/rand implements a cryptographically secure pseudo-random number generator with a limited interface.  The two packages can be combined by calling rand.New in package math/rand with a source that gets its data from crypto/rand.
import ( crand &#34;crypto/rand&#34; rand &#34;math/rand&#34; &#34;encoding/binary&#34; &#34;fmt&#34; &#34;log&#34; ) func main() { var src cryptoSource rnd := rand.</description>
    </item>
    
    <item>
      <title>Variadic functions (...T)</title>
      <link>https://yourbasic.org/golang/variadic-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/variadic-function/</guid>
      <description>Basics Pass slice elements to a variadic function Append is variadic  Basics If the last parameter of a function has type ...T it can be called with any number of trailing arguments of type&amp;nbsp;T.
func Sum(nums ...int) int { res := 0 for _, n := range nums { res += n } return res } func main() fmt.Println(Sum()) // 0 fmt.Println(Sum(1, 2, 3)) // 6 } The actual type of .</description>
    </item>
    
    <item>
      <title>Waiting for goroutines</title>
      <link>https://yourbasic.org/golang/wait-for-goroutines-waitgroup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/wait-for-goroutines-waitgroup/</guid>
      <description>A sync.WaitGroup waits for a group of goroutines to finish.
var wg sync.WaitGroup wg.Add(2) go func() { // Do work. wg.Done() }() go func() { // Do work. wg.Done() }() wg.Wait()  First the main goroutine calls Add to set the number of goroutines to wait for. Then two new goroutines run and call Done when finished.  At the same time, Wait is used to block until these two goroutines have finished.</description>
    </item>
    
    <item>
      <title>What happened to ABBA?</title>
      <link>https://yourbasic.org/golang/gotcha-trim-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-trim-string/</guid>
      <description>What&amp;rsquo;s up with strings.TrimRight?
fmt.Println(strings.TrimRight(&#34;ABBA&#34;, &#34;BA&#34;)) // Output: &#34;&#34;  Answer The Trim, TrimLeft and TrimRight functions strip all Unicode code points contained in a cutset. In this case, all trailing A:s and B:s are stripped from the string, leaving the empty string.
To strip a trailing string, use strings.TrimSuffix.
fmt.Println(strings.TrimSuffix(&#34;ABBA&#34;, &#34;BA&#34;)) // Output: &#34;AB&#34;  See String functions cheat sheet for more about strings in&amp;nbsp;Go.</description>
    </item>
    
    <item>
      <title>Whatever remains</title>
      <link>https://yourbasic.org/golang/gotcha-remainder-modulo-operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-remainder-modulo-operator/</guid>
      <description>Why isn&amp;rsquo;t -1 odd?
func Odd(n int) bool { return n%2 == 1 } func main() { fmt.Println(Odd(-1)) // false } Answer The remainder operator can give negative answers if the dividend is negative: if n is an odd negative number, n&amp;nbsp;%&amp;nbsp;2 equals&amp;nbsp;-1.
The quotient q = x&amp;nbsp;/&amp;nbsp;y and remainder r = x&amp;nbsp;%&amp;nbsp;y satisfy the relationships
x = q*y + r and |r| &amp;lt; |y|  where x / y is truncated towards zero.</description>
    </item>
    
    <item>
      <title>Where is my copy?</title>
      <link>https://yourbasic.org/golang/gotcha-copy-missing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-copy-missing/</guid>
      <description>Why does the copy disappear?
var src, dst []int src = []int{1, 2, 3} copy(dst, src) // Copy elements to dst from src. fmt.Println(&#34;dst:&#34;, dst) dst: [] Answer The number of elements copied by the copy function is the minimum of len(dst) and len(src). To make a full copy, you must allocate a big enough destination slice. var src, dst []int src = []int{1, 2, 3} dst = make([]int, len(src)) n := copy(dst, src) fmt.</description>
    </item>
    
    <item>
      <title>Where is the ternary conditional operator?</title>
      <link>https://yourbasic.org/golang/ternary-if-else-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/ternary-if-else-statement/</guid>
      <description>See 4 basic if-else statement patterns.</description>
    </item>
    
    <item>
      <title>Why doesnât append work every time? [scary bug]</title>
      <link>https://yourbasic.org/golang/gotcha-append/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/gotcha-append/</guid>
      <description>What&amp;rsquo;s up with the append function?
a := []byte(&#34;ba&#34;) a1 := append(a, &#39;d&#39;) a2 := append(a, &#39;g&#39;) fmt.Println(string(a1)) // bag fmt.Println(string(a2)) // bag Answer If there is room for more elements, append reuses the underlying array. Let&#39;s take a&amp;nbsp;look:
a := []byte(&#34;ba&#34;) fmt.Println(len(a), cap(a)) // 2 32 This means that the slices a, a1 and a2 will refer to the same underlying array in our example.
To avoid this, we need to use two separate byte&amp;nbsp;arrays.</description>
    </item>
    
    <item>
      <title>Why Go? â Key advantages you may have overlooked</title>
      <link>https://yourbasic.org/golang/advantages-over-java-python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/advantages-over-java-python/</guid>
      <description>Go makes it easier (than Java or Python) to write correct, clear and efficient code.
 Minimalism Features for the future   Code transparency Compatibility Performance  Choosing a programming language isn&amp;rsquo;t easy. The separate features of a language may look great at first, but it takes time and experience to&amp;nbsp;spot the&amp;nbsp;drawbacks.
As a CS professor and longtime Go and Java developer, I&amp;rsquo;d like to share some of my&amp;nbsp;thoughts and explain why I prefer Go to Java or Python â Go makes it much easier for me to write good&amp;nbsp;code.</description>
    </item>
    
    <item>
      <title>Write log to file (or /dev/null)</title>
      <link>https://yourbasic.org/golang/log-to-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/log-to-file/</guid>
      <description>This code appends a log message to the file text.log. It creates the file if it doesn&amp;rsquo;t already exist.
f, err := os.OpenFile(&amp;#34;text.log&amp;#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Println(err) } defer f.Close() logger := log.New(f, &amp;#34;prefix&amp;#34;, log.LstdFlags) logger.Println(&amp;#34;text to append&amp;#34;) logger.Println(&amp;#34;more text to append&amp;#34;) Contents of text.log:
prefix: 2017/10/20 07:52:58 text to append prefix: 2017/10/20 07:52:58 more text to append  log.New creates a new log.Logger that writes to f.</description>
    </item>
    
    <item>
      <title>Zero knowledge (besserwisser alert)</title>
      <link>https://yourbasic.org/golang/zero-knowledge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yourbasic.org/golang/zero-knowledge/</guid>
      <description>See Numbers that start with zero.</description>
    </item>
    
  </channel>
</rss>